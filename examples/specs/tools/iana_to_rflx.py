#!/usr/bin/env -S python3 -O

import argparse
import re
import string
import sys
from datetime import datetime
from typing import Dict, List, Optional, TextIO, Tuple, Union
from xml.etree.ElementTree import Element

import rflx.specification.const
from defusedxml import ElementTree  # type: ignore

NAMESPACE = {"iana": "http://www.iana.org/assignments"}
RESERVED_WORDS = "|".join(rflx.specification.const.RESERVED_WORDS)
DUPLICATES = []


def iana_to_rflx(xml_input: TextIO, always_valid: bool) -> None:
    xml_str = xml_input.read()
    root = ElementTree.fromstring(xml_str)
    package_name = _normalize_name(
        root.get("id"),
    )
    with open(f"{package_name.lower()}.rflx", "w+") as file:
        file.write(f"-- AUTOMATICALLY GENERATED BY {__file__}. DO NOT EDIT.\n")
        file.write(f"-- Generation date: {datetime.now().strftime('%Y-%m-%d')}\n")
        file.write(f"-- {root.find('iana:title', NAMESPACE).text}\n")
        file.write(f"-- Registry last updated on {root.find('iana:updated', NAMESPACE).text}\n\n")
        file.write(f"package {package_name} is\n\n")
        for registry in root.findall(root.tag):
            write_registry(registry, always_valid, file)
        file.write(f"end {package_name};")


def write_registry(
    registry: ElementTree,
    always_valid: bool,
    file: TextIO,
) -> None:
    if registry.find("iana:record", NAMESPACE) is None:
        return
    records = registry.findall("iana:record", NAMESPACE)
    registry_title = _normalize_name(registry.find("iana:title", NAMESPACE).text)
    normalized_records = _normalize_records(records, registry_title)
    if not normalized_records:
        return

    file.write(f"{'':<3}type {registry_title} is\n")
    file.write(f"{'':<6}(\n")
    size = max((record.bit_length for record in normalized_records))
    for record in normalized_records:
        name = record.name
        if name in DUPLICATES or re.match(RESERVED_WORDS, name, re.I | re.X) is not None:
            name += f"_{record.value.replace('#','_')}"
        if name.startswith(tuple(d for d in string.digits)):
            name = f"{registry_title}_{name}"
        DUPLICATES.append(name)

        if record.comment:
            for comment_line in record.comment:
                file.write(f"{'':<7}-- {comment_line}\n")
            file.write(f"{'':<7}--\n")
        file.write(f"{'':<7}{f'{name} => {record.value}'},\n\n")

    file.seek(file.tell() - 3)
    file.write(")\n")
    file.write(f"{'':<3}with Size => {size}")
    if always_valid and len(normalized_records).bit_length() == size:
        file.write(", Always_Valid;")
    else:
        file.write(";")
    file.write("\n\n")


def _normalize_records(records: List[Element], registry_name: str) -> List["Record"]:
    normalized_records: Dict[str, Record] = {}
    for record in records:
        name_tag = _get_name_tag(record)
        value_tag = "value"
        name = ""
        value = ""

        if (n := record.find(f"iana:{name_tag}", NAMESPACE)) is not None:
            assert isinstance(n.text, str)
            name = n.text
        if (v := record.find(f"iana:{value_tag}", NAMESPACE)) is not None:
            assert isinstance(v.text, str)
            value = v.text
        if name == "" or value == "" or re.search(r"RESERVED|UNASSIGNED", name, flags=re.I):
            continue
        comment = [
            element
            for element in record.iterfind("*", NAMESPACE)
            if element.tag
            not in [f"{{{NAMESPACE['iana']}}}{name_tag}", f"{{{NAMESPACE['iana']}}}{value_tag}"]
        ]
        r = Record(name, value, comment)
        if value in normalized_records:
            normalized_records[value].join(r, registry_name)
        else:
            normalized_records[value] = r
    return list(normalized_records.values())


def _get_name_tag(record: Element) -> str:
    sub_elements = record.findall("*", NAMESPACE)
    child_names = set(c.tag[c.tag.index("}") + 1 :] for c in sub_elements)
    possible_name_tags = ["name", "code", "type", "description"]
    for tag in possible_name_tags:
        if tag in child_names:
            return tag
    return ""


class Record:
    def __init__(self, name: str = "", value: str = "", comments: Optional[List[Element]] = None):
        self.name = _normalize_name(name)
        self.value, self.bit_length = _normalize_value(value)
        self.comment_list = comments or []
        self.alternative_names: List[str] = []

    def join(self, duplicate: "Record", registry_name: str) -> None:
        self.name = f"{registry_name}_{self.value.replace('#', '_')}"
        self.comment_list.extend(duplicate.comment_list)
        self.alternative_names.append(f"alternative_name = {duplicate.name}")

    @property
    def comment(self) -> List[str]:
        return _normalize_comment(self.comment_list, self.alternative_names)


def _normalize_comment(comment_list: List[Element], alternative_names: List[str]) -> List[str]:
    comments = [
        f"{c.tag[c.tag.index('}') + 1:]} = {c.text}"
        if c.tag is not None and c.text is not None
        else f"Ref: {c.attrib['data']}"
        for c in comment_list
    ]
    comments.extend(alternative_names)

    if (c := ", ".join(comments)) != "":
        c = c.replace("\n", " ")
        c = " ".join(c.split())
        lines = len(c) // 80 + 1
        return [c[i * 80 : i * 80 + 80] for i in range(lines)]
    return []


def _normalize_name(description_text: str) -> str:
    t = {c: " " for c in string.punctuation + "\n"}
    name = description_text.translate(str.maketrans(t))
    name = "_".join([s.capitalize() for s in name.split()])
    return name


def _normalize_value(value: str) -> Tuple[str, int]:
    if value.find("0x") != -1:
        rflx_hex = _normalize_hex_value(value)
        return rflx_hex, len(rflx_hex[3 : len(rflx_hex) - 1].lstrip("0")) * 4
    return value, int(value).bit_length()


def _normalize_hex_value(hex_value: str) -> str:
    if re.match(r"^0x[0-9A-F]{2},0x[0-9A-F]{2}$", hex_value) is not None:  # 0x0A,0xFF
        return f"16#{hex_value.replace('0x', '').replace(',', '')}#"
    if re.match(r"^0x[0-9A-F]+$", hex_value) is not None:  # 0xA1A1
        return f"16#{hex_value[2:]}#"
    raise IANAError(f"Cannot normalize hex value {hex_value}")


class IANAError(Exception):
    pass


def cli(argv: List[str]) -> Union[int, str]:
    parser = argparse.ArgumentParser(
        description="generate a RecordFlux specification file from the provided IANA XML document."
    )
    parser.add_argument(
        "-a", "--always-valid", help="add Always_Valid aspect to ech type", action="store_true"
    )
    parser.add_argument("files", type=argparse.FileType("r"), nargs="?", default=sys.stdin)
    args = parser.parse_args(argv[1:])
    try:
        iana_to_rflx(args.files, args.always_valid)
    except IANAError as e:
        return f"{e}"
    return 0


if __name__ == "__main__":
    sys.exit(cli(sys.argv))
