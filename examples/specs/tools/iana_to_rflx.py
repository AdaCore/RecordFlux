import re
import string
from datetime import datetime
from typing import List, TextIO, Tuple
from urllib.error import HTTPError
from urllib.request import urlopen

from defusedxml import ElementTree  # type: ignore

NAMESPACE = {"iana": "http://www.iana.org/assignments"}
RESERVED_WORDS = ["end", "is", "id", "package", "type", "with"]
DUPLICATES = []


def iana_to_rflx(url: str, always_valid: bool) -> None:
    if not re.match(r"^https://www\.iana\.org/assignments/.*\.xml$", url):
        raise IANAError(f"{url} not a valid IANA url")

    try:
        with urlopen(url) as xml_response:
            xml_document: str = xml_response.read().decode("utf-8")
    except HTTPError as e:
        raise IANAError(f"cannot fetch url {e}") from e

    root = ElementTree.fromstring(xml_document)
    package_name = _normalize_name(root.get("id"), "")
    with open(f"{package_name.lower()}.rflx", "w+") as file:
        file.write(f"-- AUTOMATICALLY GENERATED BY {__file__}. DO NOT EDIT.\n")
        file.write(f"-- SOURCE: {url}")
        file.write(f"-- Generation date: {datetime.now().strftime('%Y-%m-%d')}\n")
        file.write(f"-- {root.find('iana:title', NAMESPACE).text}\n")
        file.write(f"-- Registry last updated on {root.find('iana:updated', NAMESPACE).text}\n\n")
        file.write(f"package {package_name} is\n\n")
        for registry in root.findall(root.tag):
            write_registry(registry, always_valid, file)
        file.write(f"end {package_name};")


def write_registry(
    registry: ElementTree,
    always_valid: bool,
    file: TextIO,
) -> None:
    duplicates = []
    record_bit_lengths = []
    if registry.find("iana:record", NAMESPACE) is None:
        return
    DUPLICATES.clear()
    file.write(
        f"{'':<3}type {_normalize_name(registry.find('iana:title', NAMESPACE).text,'')} is\n"
    )
    file.write(f"{'':<6}(\n")
    for record in registry.iterfind("iana:record", NAMESPACE):
        record_size = write_record(record, file, duplicates)
        record_bit_lengths.append(record_size)

    file.seek(file.tell() - 2)
    file.write("\n")
    file.write(f"{'':<6})\n")
    file.write(f"{'':<3}with Size => {max(record_bit_lengths)}")
    if always_valid:
        file.write(", Always_Valid;")
    else:
        file.write(";")
    file.write("\n\n")


def write_record(record: ElementTree, file: TextIO, duplicates: List[str]) -> int:
    references = []
    name = ""
    value = ""
    sub_elements = record.findall("*", NAMESPACE)

    child_names = set(c.tag[c.tag.index("}") + 1 :] for c in sub_elements)
    possible_name_tags = ["name", "description"]  # make this definable by user via cli?
    if all((p in child_names for p in possible_name_tags)):
        name_tag = r"name"
    else:
        name_tag = child_names.intersection(possible_name_tags).pop()

    for element in sub_elements:
        if re.search(name_tag, element.tag, flags=re.IGNORECASE):
            name = element.text
        elif re.search(r"value", element.tag, flags=re.IGNORECASE):
            value = element.text
        else:
            references.append(element)

    if name == "" or value == "":
        print(f"DEBUG: {name} => {value}")
        return 0

    if re.search(r"RESERVED|UNASSIGNED", name, flags=re.IGNORECASE):
        return 0

    rflx_value, rflx_value_bit_length = _normalize_value(value)
    literal = _normalize_name(name, rflx_value)
    comment = _normalize_comment(references)

    if comment:
        file.write("\n")
        for comment_line in comment:
            file.write(f"{'':<9}-- {comment_line}\n")
        file.write(f"{'':<9}--\n")

    file.write(f"{'':<9}{f'{literal} => {rflx_value}'},\n")
    return rflx_value_bit_length


def _normalize_comment(references: list) -> List[str]:
    comment_list = [
        f"{r.tag[r.tag.index('}') + 1:]} = {r.text}"
        if r.tag is not None and r.text is not None
        else f"Ref: {r.attrib['data']}"
        for r in references
    ]

    if (c := ", ".join(comment_list)) != "":
        c = c.replace("\n", " ")
        c = " ".join(c.split())
        lines = len(c) // 80 + 1
        return [c[i * 80 : i * 80 + 80] for i in range(lines)]
    return []


def _normalize_name(description_text: str, rflx_value: str) -> str:
    t = {c: " " for c in string.punctuation + "\n"}
    name = description_text.translate(str.maketrans(t))
    name = "_".join(name.split())
    if name in DUPLICATES or re.match("|".join(RESERVED_WORDS), name, re.I | re.X) is not None:
        name = f"{name}{rflx_value}"
    DUPLICATES.append(name)
    return name.upper()


def _normalize_value(value: str) -> Tuple[str, int]:
    if value.find("0x") != -1:
        rflx_hex = _normalize_hex_value(value)
        return rflx_hex, (len(rflx_hex) - 3) * 4
    return value, int(value).bit_length()


def _normalize_hex_value(hex_value: str) -> str:
    if re.match(r"^0x[0-9A-F]{2},0x[0-9A-F]{2}$", hex_value) is not None:  # 0x0A,0xFF
        return f"16#{hex_value.replace('0x', '').replace(',', '')}#"
    elif re.match(r"^0x[0-9A-F]+$", hex_value) is not None:  # 0xA1A1
        return f"16#{hex_value[2:]}#"


class IANAError(Exception):
    pass


if __name__ == "__main__":
    iana_to_rflx(
        "https://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.xml", True
    )
