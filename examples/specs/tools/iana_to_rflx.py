import re
import string
from datetime import datetime
from typing import Dict, List, Optional, TextIO, Tuple
from urllib.error import HTTPError
from urllib.request import urlopen
from xml.etree.ElementTree import Element

import rflx.specification.const
from defusedxml import ElementTree  # type: ignore

NAMESPACE = {"iana": "http://www.iana.org/assignments"}
RESERVED_WORDS = "|".join(rflx.specification.const.RESERVED_WORDS)
DUPLICATES = []


def iana_to_rflx(url: str, always_valid: bool) -> None:
    if not re.match(r"^https://www\.iana\.org/assignments/.*\.xml$", url):
        raise IANAError(f"{url} not a valid IANA url")

    try:
        with urlopen(url) as xml_response:
            xml_document: str = xml_response.read().decode("utf-8")
    except HTTPError as e:
        raise IANAError(f"cannot fetch url {e}") from e

    root = ElementTree.fromstring(xml_document)
    package_name = _normalize_name(
        root.get("id"),
    )
    with open(f"{package_name.lower()}.rflx", "w+") as file:
        file.write(f"-- AUTOMATICALLY GENERATED BY {__file__}. DO NOT EDIT.\n")
        file.write(f"-- SOURCE: {url}")
        file.write(f"-- Generation date: {datetime.now().strftime('%Y-%m-%d')}\n")
        file.write(f"-- {root.find('iana:title', NAMESPACE).text}\n")
        file.write(f"-- Registry last updated on {root.find('iana:updated', NAMESPACE).text}\n\n")
        file.write(f"package {package_name} is\n\n")
        for registry in root.findall(root.tag):
            write_registry(registry, always_valid, file)
        file.write(f"end {package_name};")


def write_registry(
    registry: ElementTree,
    always_valid: bool,
    file: TextIO,
) -> None:
    if registry.find("iana:record", NAMESPACE) is None:
        return
    records = registry.findall("iana:record", NAMESPACE)
    registry_title = _normalize_name(registry.find('iana:title', NAMESPACE).text)
    normalized_records = _normalize_records(records, registry_title)
    if not normalized_records:
        return

    file.write(
        f"{'':<3}type {registry_title} is\n")
    file.write(f"{'':<6}(\n")
    size = max((record.bit_length for record in normalized_records))
    for record in normalized_records:
        name = record.name
        if name in DUPLICATES or re.match(RESERVED_WORDS, name, re.I | re.X) is not None:
            name += f"_{record.value.replace('#','_')}"
        if name.startswith(tuple(d for d in string.digits)):
            name = f"{registry_title}_{name}"
        DUPLICATES.append(name)

        if record.comment:
            file.write("\n")
            for comment_line in record.comment:
                file.write(f"{'':<9}-- {comment_line}\n")
            file.write(f"{'':<9}--\n")
        file.write(f"{'':<9}{f'{name} => {record.value}'},\n")

    file.seek(file.tell() - 2)
    file.write("\n")
    file.write(f"{'':<6})\n")
    file.write(f"{'':<3}with Size => {size}")
    if always_valid and len(normalized_records).bit_length() == size:
        file.write(", Always_Valid;")
    else:
        file.write(";")
    file.write("\n\n")


def _normalize_records(records: List[Element], registry_name: str) -> List["Record"]:
    normalized_records: Dict[str, Record] = {}
    for record in records:
        name_tag = _get_name_tag(record)
        value_tag = "value"
        name = ""
        value = ""

        if (n := record.find(f"iana:{name_tag}", NAMESPACE)) is not None:
            assert isinstance(n.text, str)
            name = n.text
        if (v := record.find(f"iana:{value_tag}", NAMESPACE)) is not None:
            assert isinstance(v.text, str)
            value = v.text
        if name == "" or value == "" or re.search(r"RESERVED|UNASSIGNED", name, flags=re.I):
            continue
        comment = [
            element
            for element in record.iterfind("*", NAMESPACE)
            if element.tag not in [name_tag, value_tag]
        ]
        r = Record(name, value, comment)
        if value in normalized_records:
            normalized_records[value].join(r, registry_name)
        else:
            normalized_records[value] = r
    return list(normalized_records.values())


def _get_name_tag(record: Element) -> str:
    sub_elements = record.findall("*", NAMESPACE)
    child_names = set(c.tag[c.tag.index("}") + 1 :] for c in sub_elements)
    possible_name_tags = ["name", "description", "code", "type"]
    if all((p in child_names for p in possible_name_tags)):
        return "name"
    return child_names.intersection(possible_name_tags).pop()


class Record:
    def __init__(self, name: str = "", value: str = "", comments: Optional[List[Element]] = None):
        self.name = _normalize_name(name)
        self.value, self.bit_length = _normalize_value(value)
        self.comment_list = comments or []

    def join(self, duplicate: "Record", registry_name: str) -> None:
        self.name = f"{registry_name}_{self.value.replace('#', '_')}"
        self.comment_list.extend(duplicate.comment_list)

    @property
    def comment(self) -> List[str]:
        return _normalize_comment(self.comment_list)


def _normalize_comment(comment_list: List[Element]) -> List[str]:
    comments = [
        f"{c.tag[c.tag.index('}') + 1:]} = {c.text}"
        if c.tag is not None and c.text is not None
        else f"Ref: {c.attrib['data']}"
        for c in comment_list
    ]

    if (c := ", ".join(comments)) != "":
        c = c.replace("\n", " ")
        c = " ".join(c.split())
        lines = len(c) // 80 + 1
        return [c[i * 80 : i * 80 + 80] for i in range(lines)]
    return []


def _normalize_name(description_text: str) -> str:
    t = {c: " " for c in string.punctuation + "\n"}
    name = description_text.translate(str.maketrans(t))
    name = "_".join(name.split())
    return name.upper()


def _normalize_value(value: str) -> Tuple[str, int]:
    if value.find("0x") != -1:
        rflx_hex = _normalize_hex_value(value)
        return rflx_hex, (len(rflx_hex) - 3) * 4
    return value, int(value).bit_length()


def _normalize_hex_value(hex_value: str) -> str:
    if re.match(r"^0x[0-9A-F]{2},0x[0-9A-F]{2}$", hex_value) is not None:  # 0x0A,0xFF
        return f"16#{hex_value.replace('0x', '').replace(',', '')}#"
    if re.match(r"^0x[0-9A-F]+$", hex_value) is not None:  # 0xA1A1
        return f"16#{hex_value[2:]}#"
    raise IANAError(f"Cannot normalize hex value {hex_value}")


class IANAError(Exception):
    pass


if __name__ == "__main__":
    iana_to_rflx(
        "https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml", True
    )
