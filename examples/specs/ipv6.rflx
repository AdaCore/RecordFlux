with IPv6_Address;
with Protocol_Numbers;

package IPv6 is

   --  Types

   --  The value [...] MUST be ignored by the receiver
   --  ISSUE: Componolit/systematization-binary-schemas#55
   type Reserved_2  is range 0 .. 0 with Size => 2;
   type Reserved_8  is range 0 .. 0 with Size => 8;
   type Reserved_15 is range 0 .. 0 with Size => 15;
   type Reserved_20 is range 0 .. 0 with Size => 20;
   type Reserved_32 is range 0 .. 0 with Size => 32;

   --  Options (RFC 8200, 4.2)

   type Option_Action is
      (Skip                                        => 0,
       Discard                                     => 1,
       Discard_With_Parameter_Problem              => 2,
       Discard_With_Parameter_Problem_If_Multicast => 3) with Size => 2;

   type Option_Value is
      (Pad1 => 0,
       PadN => 1) with Size => 5;

   type Option_Kind is
      message
         Action     : Option_Action;
         May_Change : Boolean;
         Value      : Option_Value;
      end message;

   type Data_Len is range 0 .. 2**8 - 1 with Size => 8;

   type Option is
      message
         Kind : Option_Kind
            then null
               if Kind_Action = Skip and Kind_May_Change = False and Kind_Value = Pad1
            then Len
               if Kind_Action /= Skip or Kind_May_Change = True or Kind_Value /= Pad1;
         Len  : Data_Len
            then Data
               with Size => 8 * Len;
         Data : Opaque;
      end message;

   type Options is array of Option;

   type Options_Header is
      message
         Next_Header : Protocol_Numbers::Protocol;
         Hdr_Ext_Len : Data_Len
            then Options
               with Size => 40 + 64 * Hdr_Ext_Len;
         Options     : Options
            then null
               if Message'Size mod 64 = 0;
      end message;

   --  Hop-by-Hop Options Header (RFC 8200, 4.3)

   type Hop_By_Hop_Options_Header is new Options_Header;

   --  Routing Header (RFC 8200, 4.4)

   --  Routing types
   --  https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters-3.csv
   type Routing_Type is
      (RT_Type_2           => 2,
       RT_RPL_Source_Route => 3,
       RT_Segment_Routing  => 4,
       RT_Experiment_1     => 253,
       RT_Experiment_2     => 254,
       RT_Reserved         => 255) with Size => 8, Always_Valid;

   type Segments_Count is range 0 .. 2**8 - 1 with Size => 8;

   type Routing_Header is
      message
         Next_Header  : Protocol_Numbers::Protocol;
         Hdr_Ext_Len  : Data_Len;
         Routing_Type : Routing_Type
            then Data
               with Size => 40 + 64 * Hdr_Ext_Len;
         Data         : Opaque
            then null
               if Message'Size mod 64 = 0;
      end message;

   --  Type 2 routing header (RFC 6275, 6.4)
   type Routing_Header_Type_2 is
      message
         Segments_Left : Segments_Count
            then Reserved
               if Segments_Left = 1;
         Reserved      : Reserved_32;
         Home_Address  : IPv6_Address::Address;
      end message;

   for Routing_Header use (Data => Routing_Header_Type_2)
      if Hdr_Ext_Len = 2 and Routing_Type = RT_Type_2;

   --  RPL Routing Header (RFC 6554, 3)

   type Cmpr_Length is range 0 .. 15 with Size => 4;
   type Pad_Length is range 0 .. 15 with Size => 4;

   --  ISSUE: Componolit/systematization-binary-schemas#57
   --  As per RFC 6554, section 3, the segments sent in the RPL routing header actually are a
   --  vector of addresses. However, these are not fixed-size IPv6 addresses, but they are
   --  truncated depending on the values of CmprI and CmprE. We cannot specify this as, a normal
   --  sequence because those require a static element type.
   type RPL_Routing_Header is
      message
         Segments_Left : Segments_Count;
         CmprI         : Cmpr_Length;
         CmprE         : Cmpr_Length;
         Pad           : Pad_Length;
         Reserved      : Reserved_20
            then Padding
               with Size => 8 * Pad
                  if Segments_Left = 0
            then Last_Segment
               with Size => 8 * (16 - CmprE)
                  if Segments_Left = 1
            then Segments
               with Size => Segments_Left * 8 * (16 - CmprI)
                  if Segments_Left > 1;
         Segments      : Opaque
            then Last_Segment
               with Size => 8 * (16 - CmprE);
         Last_Segment : Opaque
            then Padding
               with Size => 8 * Pad;
         Padding      : Opaque;
      end message;

   for Routing_Header use (Data => RPL_Routing_Header)
      if Routing_Type = RT_RPL_Source_Route;

   --  Segment Routing Header, SRH (RFC 8754, 2)

   type SRH_Last_Entry_Index is range 0 .. 2**8 - 1 with Size => 8;
   type SRH_Tag is range 0 .. 2**16 - 1 with Size => 16;

   type SRH_TLV_Kind is
      (SRH_TK_Pad1         =>   0,
       SRH_TK_Reserved_1   =>   1,
       SRH_TK_Reserved_2   =>   2,
       SRH_TK_Reserved_3   =>   3,
       SRH_TK_PadN         =>   4,
       SRH_TK_HMAC         =>   5,
       SRH_TK_Reserved_6   =>   6,
       SRH_TK_EuT_124      => 124,
       SRH_TK_EuT_125      => 125,
       SRH_TK_EuT_126      => 126,
       SRH_TK_EuT_252      => 252,
       SRH_TK_EuT_253      => 253,
       SRH_TK_EuT_254      => 254,
       SRH_TK_Reserved_255 => 255) with Size => 8, Always_Valid;

   type SRH_TLV is
      message
         Kind   : SRH_TLV_Kind
            then null
               if Kind = SRH_TK_Pad1
            then Length
               if Kind /= SRH_TK_Pad1;
         Length : Data_Len
            then Data
               with Size => 8 * Length;
         Data   : Opaque;
      end message;

   type SRH_HMAC_Key_ID is mod 2**32;

   type SRH_HMAC_TLV is
      message
         Dest_Addr_Verification_Disable : Boolean;
         Reserved                       : Reserved_15;
         HMAC_Key_ID                    : SRH_HMAC_Key_ID;
         HMAC                           : Opaque
            with Size => Message'Last - HMAC_Key_ID'Last;
      end message;

   for SRH_TLV use (Data => SRH_HMAC_TLV)
      if Kind = SRH_TK_HMAC;

   type Segment_Routing_Header is
      message
         Segments_Left : Segments_Count;
         Last_Entry    : SRH_Last_Entry_Index;
         Flags         : Reserved_8;
         Tag           : SRH_Tag
            then Segments
               with Size => 128 * (Last_Entry + 1);
         Segments      : IPv6_Address::Addresses;
      end message;

   for Routing_Header use (Data => Segment_Routing_Header)
      if Routing_Type = RT_Segment_Routing;

   --  Fragment Header (RFC 8200, 4.5)

   type FH_Offset is range 0 .. 2**13 - 1 with Size => 13;
   type FH_Identification is mod 2**32;

   type Fragment_Header is
      message
         Next_Header     : Protocol_Numbers::Protocol;
         Reserved        : Reserved_8;
         Fragment_Offset : FH_Offset;
         More_Fragments  : Boolean;
         Identification  : FH_Identification;
      end message;

   --  Destination Options Header (RFC 8200, 4.6)

   type Destination_Options_Header is new Options_Header;

   --  Packet (RFC 8200, 3)

   type Version is range 6 .. 6 with Size => 4;
   type Traffic_Class is mod 2**8;
   type Flow_Label is mod 2**20;
   type Payload_Length is range 0 .. 2**16 - 1 with Size => 16;
   type Hop_Limit is range 0 .. 2**8 - 1 with Size => 8;

   type Packet is
      message
         Version        : Version;
         Traffic_Class  : Traffic_Class;
         Flow_Label     : Flow_Label;
         Payload_Length : Payload_Length;
         Next_Header    : Protocol_Numbers::Protocol;
         Hop_Limit      : Hop_Limit;
         Source         : IPv6_Address::Address;
         Destination    : IPv6_Address::Address
            then Data
               with Size => 8 * Payload_Length
               if Payload_Length > 0
            --  ISSUE: Componolit/RecordFlux#533
            then null
               if Payload_Length = 0;
         Data           : Opaque;
      end message;

end IPv6;
