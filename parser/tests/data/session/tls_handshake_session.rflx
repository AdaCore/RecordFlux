with GreenTLS;
with TLS_Alert;
with TLS_Handshake;

package TLS_Handshake_Session is

   generic
      Record_Data_Channel : Channel with Readable, Writable;
      Record_Control_Channel : Channel with Writable;
      RNG_Channel : Channel with Readable, Writable;
      Keystore_Channel : Channel with Readable, Writable;
      Application_Control_Channel : Channel with Readable, Writable;
      Configuration_Channel : Channel with Readable;
      Connection_Channel : Channel with Readable;

      type Hash_Context is private;

      with function Calculate_Binders (PSKs : GreenTLS::PSKs; Transcript_Hash : GreenTLS::Content) return TLS_Handshake::PSK_Binder_Entries;
      with function Calculate_Binders_Length (PSKs : GreenTLS::PSKs) return TLS_Handshake::Binders_Length;
      with function Calculate_ECDHE_Key (Client_Share : TLS_Handshake::Key_Share_Entry; Server_Share : TLS_Handshake::Key_Share_SH) return GreenTLS::Content;
      with function Create_Client_Hello_Extensions (Configuration : GreenTLS::Configuration) return TLS_Handshake::CH_Extensions;
      with function Derive_Secret (Secret : GreenTLS::Content; Label : Opaque; Transcript_Hash : GreenTLS::Content) return GreenTLS::Content;
      with function Empty_Hash return Hash_Context;
      with function Get_Hash (Context : Hash_Context) return GreenTLS::Content;
      with function Get_Hash_Length (Cipher_Suite : TLS_Handshake::Cipher_Suite) return GreenTLS::KM_Length;
      with function Get_Zero_Content (Length : GreenTLS::KM_Length) return GreenTLS::Content;
      with function HKDF_Expand_Label (Secret : GreenTLS::Content; Label : Opaque; Context : GreenTLS::Content; Length : GreenTLS::KM_Length) return GreenTLS::Content;
      with function HKDF_Extract (Salt : GreenTLS::Content; IKM : GreenTLS::Content) return GreenTLS::Content;
      with function HMAC (Cipher_Suite : TLS_Handshake::Cipher_Suite; Key : GreenTLS::Content; Hash : GreenTLS::Content) return GreenTLS::Content;
      with function Select_Supported_Groups (Server_Preferred_Groups : TLS_Handshake::Named_Groups; Supported_Groups : TLS_Handshake::Named_Groups) return TLS_Handshake::Named_Groups;
      with function Truncate_Client_Hello (Client_Hello : TLS_Handshake::Handshake) return GreenTLS::Content;
      with function Update_Hash (Context : Hash_Context; Data : Opaque) return Hash_Context;
      with function Validate_Certificate_Verify_Signature (Certificate_Message : TLS_Handshake::Certificate; Certificate_Verify_Message : TLS_Handshake::Certificate_Verify; Transcript_Hash : GreenTLS::Content) return GreenTLS::Signature_Validation_Result;
      with function Validate_Server_Certificate (Certificate_Message : TLS_Handshake::Certificate; Configuration : GreenTLS::Configuration; Connection : GreenTLS::Connection) return GreenTLS::Certificate_Validation_Result;
   session Client with
      Initial => START,
      Final => TERMINATED
   is
      Application_Layer_Protocol_Negotiation_Received : Boolean := False;
      Binders : TLS_Handshake::PSK_Binder_Entries;
      Binders_Length : TLS_Handshake::Binders_Length;
      CCR_Handshake_Message : TLS_Handshake::Handshake;
      CH_Cookie_Prepared : Boolean := False;
      CH_Key_Share_Prepared : Boolean := False;
      CH_PSK_Prepared : Boolean := False;
      Certificate_Authorities : TLS_Handshake::Certificate_Authorities;
      Certificate_Authorities_Received : Boolean := False;
      Certificate_Request : TLS_Handshake::Certificate_Request;
      Certificate_Request_Received : Boolean := False;
      Certificate_Verify_Handshake_Message : TLS_Handshake::Handshake;
      Client_Application_Traffic_Secret : GreenTLS::Content;
      Client_Handshake_Traffic_Secret : GreenTLS::Content;
      Client_Hello_1_Hash : Hash_Context;
      Client_Hello_Handshake_Message : TLS_Handshake::Handshake;
      Client_Shares : TLS_Handshake::Key_Share_Entries;
      Configuration : GreenTLS::Configuration;
      Connection : GreenTLS::Connection;
      DHE_Accepted : Boolean := False;
      Derived_Handshake_Secret : GreenTLS::Content;
      Early_Data_Received : Boolean := False;
      Early_Secret : GreenTLS::Content;
      Encrypted_Extensions_Handshake_Message : TLS_Handshake::Handshake;
      Error : TLS_Alert::Alert_Description;
      Extensions_List : TLS_Handshake::CH_Extensions;
      Finished_Key : GreenTLS::Content;
      Finished_Handshake_Message : TLS_Handshake::Handshake;
      Hash_Length : GreenTLS::KM_Length;
      Heartbeat_Received : Boolean := False;
      Identity_Index : TLS_Handshake::Identity_Index;
      Keystore_Message : GreenTLS::Keystore_Message;
      Max_Fragment_Length : TLS_Handshake::Max_Fragment_Length_Value;
      Max_Fragment_Length_Received : Boolean := False;
      OID_Filters : TLS_Handshake::OID_Filters;
      OID_Filters_Received : Boolean := False;
      PSK_Identities : TLS_Handshake::PSK_Identities;
      PSKs : GreenTLS::PSKs;
      Post_Handshake_Handshake_Message : TLS_Handshake::Handshake;
      Random_Message : GreenTLS::RNG_Message;
      Pre_Shared_Key_CH : TLS_Handshake::Pre_Shared_Key_CH;
      Resumption_Master_Secret : GreenTLS::Content;
      Retry_Request_Received : Boolean := False;
      Selected_Group : TLS_Handshake::Named_Group;
      Server_Application_Traffic_Secret : GreenTLS::Content;
      Server_Handshake_Traffic_Secret : GreenTLS::Content;
      Server_Hello_Handshake_Message : TLS_Handshake::Handshake;
      Server_Name_Extension : TLS_Handshake::EE_Extension;
      Server_Name_Received : Boolean := False;
      Server_Preferred_Groups : TLS_Handshake::Supported_Groups;
      Signature_Algorithms : TLS_Handshake::Signature_Algorithms;
      Signature_Algorithms_Cert : TLS_Handshake::Signature_Algorithms_Cert;
      Signature_Algorithms_Cert_Received : Boolean := False;
      Signature_Algorithms_Received : Boolean := False;
      Success : Boolean;
      Supported_Groups : TLS_Handshake::Named_Groups;
      Supported_Groups_Received : Boolean := False;
      Transcript_Hash : Hash_Context;

      Certificate_Message : TLS_Handshake::Certificate renames CCR_Handshake_Message.Payload;
      Certificate_Request_Message : TLS_Handshake::Certificate_Request renames CCR_Handshake_Message.Payload;
      Certificate_Verify_Message : TLS_Handshake::Certificate_Verify renames Certificate_Verify_Handshake_Message.Payload;
      Client_Hello_Message : TLS_Handshake::Client_Hello renames Client_Hello_Handshake_Message.Payload;
      Encrypted_Extensions_Message : TLS_Handshake::Encrypted_Extensions renames Encrypted_Extensions_Handshake_Message.Payload;
      Finished_Message : TLS_Handshake::Finished renames Finished_Handshake_Message.Payload;
      Key_Update_Message : TLS_Handshake::Key_Update renames Post_Handshake_Handshake_Message.Payload;
      New_Session_Ticket_Message : TLS_Handshake::New_Session_Ticket renames Post_Handshake_Handshake_Message.Payload;
      PHA_Certificate_Request_Message : TLS_Handshake::Certificate_Request renames Post_Handshake_Handshake_Message.Payload;
      Server_Hello_Message : TLS_Handshake::Server_Hello renames Server_Hello_Handshake_Message.Payload;
   begin
      state START is
      begin
         Connection_Channel'Read (Connection);
         Configuration_Channel'Read (Configuration);
      transition
         goto ERROR_INTERNAL_ERROR
            if Connection'Valid = False
         goto ERROR_INTERNAL_ERROR
            if Configuration'Valid = False
         goto SERVER_PREFERRED_GROUPS
      end START;

      state SERVER_PREFERRED_GROUPS is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS, Length => 0, Payload => []));
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS::KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS::KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS
         goto SERVER_PREFERRED_GROUPS_CONFIGURE
      end SERVER_PREFERRED_GROUPS;

      state SERVER_PREFERRED_GROUPS_CONFIGURE is
      begin
         Server_Preferred_Groups := TLS_Handshake::Supported_Groups (Keystore_Message.Payload);
      transition
         goto ERROR_INTERNAL_ERROR
            if Server_Preferred_Groups'Valid = False
         goto SERVER_PREFERRED_GROUPS_SELECT
      end SERVER_PREFERRED_GROUPS_CONFIGURE;

      state SERVER_PREFERRED_GROUPS_SELECT is
      begin
         Supported_Groups := Select_Supported_Groups (Server_Preferred_Groups.Groups, Configuration.Supported_Groups_Groups);
      transition
         goto CREATE_CLIENT_HELLO_EXTENSIONS
      end SERVER_PREFERRED_GROUPS_SELECT;

      state CREATE_CLIENT_HELLO_EXTENSIONS is
         Supported_Version : TLS_Handshake::Supported_Version;
         Supported_Versions_Extension : TLS_Handshake::CH_Extension;
      begin
         Supported_Version := TLS_Handshake::Supported_Version'(Version => TLS_Handshake::TLS_1_3);
         Supported_Versions_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_SUPPORTED_VERSIONS, Data_Length => Supported_Version'Size, Data => Supported_Version'Opaque);
         Extensions_List'Append (Supported_Versions_Extension);
         Extensions_List'Extend (Create_Client_Hello_Extensions (Configuration));
      transition
         goto ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         goto START_POST_HANDSHAKE_AUTH_EXTENSION
            if Configuration.Post_Handshake_Auth_Enabled = True
         goto START_DHE
            if TLS_Handshake::PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes_Modes
         goto START_PSK
            if TLS_Handshake::PSK_KE in Configuration.PSK_Key_Exchange_Modes_Modes
         goto ERROR_INTERNAL_ERROR
      end CREATE_CLIENT_HELLO_EXTENSIONS;

      state START_POST_HANDSHAKE_AUTH_EXTENSION is
         Post_Handshake_Auth_Extension : TLS_Handshake::CH_Extension;
      begin
         Post_Handshake_Auth_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_POST_HANDSHAKE_AUTH, Data_Length => 0, Data => []);
         Extensions_List'Append (Post_Handshake_Auth_Extension);
      transition
         goto ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         goto START_DHE
            if TLS_Handshake::PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes_Modes
         goto START_PSK
            if TLS_Handshake::PSK_KE in Configuration.PSK_Key_Exchange_Modes_Modes
         goto ERROR_INTERNAL_ERROR
      end START_POST_HANDSHAKE_AUTH_EXTENSION;

      state START_DHE is
         Supported_Groups_Extension : TLS_Handshake::CH_Extension;
         Key_Share_Extension : TLS_Handshake::CH_Extension;
         Signature_Algorithms_Extension : TLS_Handshake::CH_Extension;
      begin
         Supported_Groups_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_SUPPORTED_GROUPS, Data_Length => Modes'Size, Data => Modes)
            where Modes = TLS_Handshake::Supported_Groups'(Length => Configuration.Supported_Groups_Length, Groups => Configuration.Supported_Groups_Groups);
         Extensions_List'Append (Supported_Groups_Extension);
         Key_Share_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_KEY_SHARE, Data_Length => Modes'Size, Data => Modes)
            where Modes = TLS_Handshake::Key_Share_CH'(Length => Configuration.Key_Shares_Length, Shares => Configuration.Key_Shares_Shares);
         Extensions_List'Append (Key_Share_Extension);
         Signature_Algorithms_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS, Data_Length => Modes'Size, Data => Modes)
            where Modes = TLS_Handshake::Signature_Algorithms'(Length => Configuration.Signature_Algorithms_Length, Algorithms => Configuration.Signature_Algorithms_Algorithms);
         Extensions_List'Append (Signature_Algorithms_Extension);
      transition
         goto ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         goto START_DHE_SIGNATURE_ALGORITHMS
            with Desc => "rfc8446.txt+2259:43-2261:36"
            if Configuration.Server_Augototication_Enabled = True
         goto START_PSK
            if TLS_Handshake::PSK_KE in Configuration.PSK_Key_Exchange_Modes_Modes
         goto START_SEND
      end START_DHE;

      state START_DHE_SIGNATURE_ALGORITHMS is
         Signature_Algorithms_Cert_Extension : TLS_Handshake::CH_Extension;
      begin
         Signature_Algorithms_Cert_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS_CERT, Data_Length => Modes'Size, Data => Modes)
            where Modes = TLS_Handshake::Signature_Algorithms_Cert'(Length => Configuration.Signature_Algorithms_Cert_Length, Algorithms => Configuration.Signature_Algorithms_Cert_Algorithms);
         Extensions_List'Append (Signature_Algorithms_Cert_Extension);
      transition
         goto ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         goto START_PSK
            if TLS_Handshake::PSK_KE in Configuration.PSK_Key_Exchange_Modes_Modes
         goto START_SEND
      end START_DHE_SIGNATURE_ALGORITHMS;

      state START_PSK is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_PSKS, Length => Connection'Size, Payload => Connection));
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS::KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS::KEYSTORE_REQUEST_PSKS
               or (Keystore_Message.Length = 0
                   and TLS_Handshake::PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes_Modes)
         goto START_SEND
            if Keystore_Message.Length = 0
         goto START_PSK_EXTENSION_CHECK
      end START_PSK;

      state START_PSK_EXTENSION_CHECK is
      begin
         PSKs := GreenTLS::PSK_Message (Keystore_Message.Payload).PSKs;
         Binders_Length := Calculate_Binders_Length (PSKs);
         PSK_Identities := [for K in PSKs => TLS_Handshake::PSK_Identity'(Length => K.Identity_Length, Identity => K.Identity_Identity, Obfuscated_Ticket_Age => K.Identity_Obfuscated_Ticket_Age)];
         Pre_Shared_Key_CH := TLS_Handshake::Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Size, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => []);
      transition
         goto ERROR_INTERNAL_ERROR
            if Pre_Shared_Key_CH'Valid = False
         goto START_GET_RANDOM
      end START_PSK_EXTENSION_CHECK;

      state START_GET_RANDOM is
      begin
         RNG_Channel'Write (GreenTLS::RNG_Message'(Tag => GreenTLS::RNG_REQUEST, Length => 32));
         RNG_Channel'Read (Random_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Random_Message'Valid = False
               or Random_Message.Tag /= GreenTLS::RNG_RESPONSE
               or Random_Message.Length /= 32
         goto START_PSK_EXTENSIONS
      end START_GET_RANDOM;

      state START_PSK_EXTENSIONS is
         PSK_Key_Exchange_Modes_Extension : TLS_Handshake::CH_Extension;
         Client_Hello_Hash : Hash_Context;
      begin
         PSK_Key_Exchange_Modes_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Size, Data => Modes)
            where Modes = TLS_Handshake::PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes_Modes);
         Extensions_List'Append (PSK_Key_Exchange_Modes_Extension);
         Extensions_List'Append (TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_PRE_SHARED_KEY, Data_Length => Pre_Shared_Key_CH'Size, Data => Pre_Shared_Key_CH));
         Client_Hello_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CLIENT_HELLO, Length => CH'Size, Payload => CH)
            where CH = TLS_Handshake::Client_Hello'(Legacy_Version => TLS_Handshake::TLS_1_2, Random => Random_Message.Data, Legacy_Session_ID_Length => 0, Legacy_Session_ID => [], Cipher_Suites_Length => Configuration.Cipher_Suites'Size, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Legacy_Compression_Methods => [], Extensions_Length => Extensions_List'Size, Extensions => Extensions_List);
         Client_Hello_Hash := Empty_Hash;
         Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash));
         Extensions_List := [for E in Extensions_List if E.Tag /= TLS_Handshake::EXTENSION_PRE_SHARED_KEY => E];
         Extensions_List'Append (TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_PRE_SHARED_KEY, Data_Length => PSK_CH'Size, Data => PSK_CH)
            where PSK_CH = TLS_Handshake::Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Size, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => Binders));
      transition
         goto ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         goto START_SEND
      end START_PSK_EXTENSIONS;

      state START_SEND is
      begin
         Record_Data_Channel'Write (Client_Hello_Handshake_Message);
         Client_Hello_1_Hash := Empty_Hash;
         Client_Hello_1_Hash := Update_Hash (Client_Hello_1_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Transcript_Hash := Empty_Hash;
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Opaque);
         Client_Hello_Message := TLS_Handshake::Client_Hello (Client_Hello_Handshake_Message.Payload);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto START_SEND_CLIENT_EARLY_TRAFFIC_SECRET
            if Configuration.Early_Data_Enabled = True
         goto WAIT_SH
      end START_SEND;

      state START_SEND_CLIENT_EARLY_TRAFFIC_SECRET
         with Desc => "rfc8446.txt+2938:43-2940:30"
      is
         Client_Early_Traffic_Secret : GreenTLS::Content;
         Client_Key : GreenTLS::Content;
         Client_IV : GreenTLS::Content;
      begin
         Early_Secret := HKDF_Extract (Get_Zero_Content (Get_Hash_Length (PSKs'Head.Cipher_Suite)), GreenTLS::Content'(Data => PSKs'Head.Key));
         Client_Early_Traffic_Secret := Derive_Secret (Early_Secret, "c e traffic", Get_Hash (Transcript_Hash));
         -- FIXME: Replace 256 by key length and IV length determined by keystore
         Client_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Early_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Client_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Early_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Keystore_Message'Reset;
         Record_Data_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_CLIENT, Length => KU'Size, Data => KU)
            where KU = GreenTLS::Key_Update_Message'(Key_Length => Client_Key'Size, Key => Client_Key.Data, IV_Length => Client_IV'Size, IV => Client_IV.Data));
         Client_Early_Traffic_Secret'Reset;
         Client_Key'Reset;
         Client_IV'Reset;
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto WAIT_SH
      end START_SEND_CLIENT_EARLY_TRAFFIC_SECRET;

      state WAIT_SH is
      begin
         Record_Data_Channel'Read (Server_Hello_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Server_Hello_Handshake_Message'Opaque);
      transition
         goto ERROR_DECODE_ERROR
            if Server_Hello_Handshake_Message'Valid = False
         goto ERROR_UNEXPECTED_MESSAGE
            if Server_Hello_Handshake_Message.Tag /= TLS_Handshake::HANDSHAKE_SERVER_HELLO
         goto ERROR_DECODE_ERROR
            if Server_Hello_Message'Valid = False
         goto ERROR_PROTOCOL_VERSION
            if Server_Hello_Message.Legacy_Version /= TLS_Handshake::TLS_1_2
         goto ERROR_ILLEGAL_PARAMETER
            if Server_Hello_Message.Legacy_Session_ID_Length /= 0
               or Server_Hello_Message.Legacy_Compression_Method /= 0
         goto ERROR_ILLEGAL_PARAMETER
            if Server_Hello_Message.Cipher_Suite not in Client_Hello_Message.Cipher_Suites
         goto ERROR_MISSING_EXTENSION
            if (for all E in Server_Hello_Message.Extensions =>
                   E.Tag /= TLS_Handshake::EXTENSION_SUPPORTED_VERSIONS)
         goto ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_SUPPORTED_VERSIONS
                   and TLS_Handshake::TLS_1_3 /= TLS_Handshake::Supported_Version (E.Data).Version)
         goto ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag not in [for E in Client_Hello_Message.Extensions => E.Tag])
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+2770:46-2771:59"
            if TLS_Handshake::PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes_Modes
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE)
         goto WAIT_SH_PARSE_HRR
            if Server_Hello_Message.HRR_Extensions'Present
               and Retry_Request_Received = False
         goto ERROR_UNEXPECTED_MESSAGE
            if Server_Hello_Message.HRR_Extensions'Present = False
               and Retry_Request_Received = True
         goto WAIT_SH_EXTENSIONS_PSK
            with Desc => "rfc8446.txt+643:57-646:21"
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_PRE_SHARED_KEY)
         goto WAIT_SH_EXTENSIONS_DHE
            with Desc => "rfc8446.txt+640:45-642:47"
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE)
         goto ERROR_INVALID_CONFIGURATION
      end WAIT_SH;

      state WAIT_SH_EXTENSIONS_PSK is
      begin
         Identity_Index := TLS_Handshake::Pre_Shared_Key_SH ([for E in Server_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_PRE_SHARED_KEY => E]'Head.Data).Selected_Identity;
      transition
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+3199:4-3202:29"
            if Identity_Index /= 0
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_EARLY_DATA)
         goto ERROR_ILLEGAL_PARAMETER
            if (for some E in Client_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_PRE_SHARED_KEY
                   and TLS_Handshake::Pre_Shared_Key_CH (E.Data).Identities'Size < Identity_Index)
         goto WAIT_SH_EXTENSIONS_PSK_REQUEST
      end WAIT_SH_EXTENSIONS_PSK;

      state WAIT_SH_EXTENSIONS_PSK_REQUEST is
      begin
         --  FIXME: use Identity_Index to determine Selected_Identity
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_PSKS, Length => Selected_Identity'Size, Payload => Selected_Identity)
            where Selected_Identity = []);
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS::KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS::KEYSTORE_REQUEST_PSKS
               or GreenTLS::PSK_Message (Keystore_Message.Payload)'Valid = False
         goto WAIT_SH_EXTENSIONS_PSK_VALIDATION
      end WAIT_SH_EXTENSIONS_PSK_REQUEST;

      state WAIT_SH_EXTENSIONS_PSK_VALIDATION is
         Identity_Cipher_Suite : TLS_Handshake::Cipher_Suite;
      begin
         Identity_Cipher_Suite := GreenTLS::PSK_Message (Keystore_Message.Payload).PSKs'Head.Cipher_Suite;
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if Identity_Cipher_Suite /= Server_Hello_Message.Cipher_Suite
         goto WAIT_SH_EXTENSIONS_DHE
            with Desc => "rfc8446.txt+2765:4-2766:36, rfc8446.txt+646:24-647:60"
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE)
         goto SET_RECORD_KEYS
      end WAIT_SH_EXTENSIONS_PSK_VALIDATION;

      state WAIT_SH_EXTENSIONS_DHE is
      begin
         Selected_Group := TLS_Handshake::Key_Share_SH ([for E in Server_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE => E]'Head.Data).Group;
         DHE_Accepted := True;
      transition
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+2766:39-2768:55"
            if (for some S in TLS_Handshake::Key_Share_CH ([for E in Client_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE => E]'Head.Data).Shares =>
                   S.Group = Selected_Group) = False
         goto SET_RECORD_KEYS
      end WAIT_SH_EXTENSIONS_DHE;

      state WAIT_SH_PARSE_HRR is
         Client_Supported_Groups : TLS_Handshake::Named_Groups;
      begin
         Retry_Request_Received := True;
         Client_Supported_Groups := TLS_Handshake::Supported_Groups ([for E in Client_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SUPPORTED_GROUPS => E]'Head.Data).Groups;
         Client_Shares := TLS_Handshake::Key_Share_CH ([for E in Client_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE => E]'Head.Data).Shares;
      transition
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+1825:70-1829:28"
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag not in [for E in Client_Hello_Message.Extensions => E.Tag]
                   and E.Tag /= TLS_Handshake::EXTENSION_COOKIE)
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+2736:21-2738:23"
            if (for some E in Server_Hello_Message.HRR_Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE
                   and TLS_Handshake::Key_Share_HRR (E.Data).Selected_Group not in Client_Supported_Groups)
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+2738:29-2740:31"
            if (for some E in Server_Hello_Message.HRR_Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE
                   and (for some S in Client_Shares =>
                           S.Group = TLS_Handshake::Key_Share_HRR (E.Data).Selected_Group))
         goto WAIT_SH_PREPARE_CH
      end WAIT_SH_PARSE_HRR;

      state WAIT_SH_PREPARE_CH
         with Desc => "rfc8446.txt+1497:7-1498:70"
      is
      begin
         Extensions_List'Reset;
         Extensions_List'Extend ([for E in Client_Hello_Message.Extensions
                                  if E.Tag /= TLS_Handshake::EXTENSION_KEY_SHARE
                                     and E.Tag /= TLS_Handshake::EXTENSION_EARLY_DATA
                                     and E.Tag /= TLS_Handshake::EXTENSION_PRE_SHARED_KEY
                                  => E]);
      transition
         goto WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PREPARE_CH;

      state WAIT_SH_PREPARE_CH_DISPATCH is
      begin
      transition
         goto WAIT_SH_PREPARE_CH_KEY_SHARE
            if CH_Key_Share_Prepared = False
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE)
         goto WAIT_SH_PREPARE_CH_COOKIE
            if CH_Cookie_Prepared = False
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_COOKIE)
         goto WAIT_SH_PREPARE_CH_PSK
            if CH_PSK_Prepared = False
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_PRE_SHARED_KEY)
         goto WAIT_SH_SEND_CH
      end WAIT_SH_PREPARE_CH_DISPATCH;

      state WAIT_SH_PREPARE_CH_KEY_SHARE
         with Desc => "rfc8446.txt+2742:12-2753:39"
      is
      begin
         Extensions_List'Append (TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_KEY_SHARE, Data_Length => Key_Share'Size, Data => Key_Share)
            where Key_Share = TLS_Handshake::Key_Share_CH'(Length => Entries'Size, Shares => Entries)
                     where Entries = [for E in Client_Shares if E.Group = Selected_Group => E]);
         CH_Key_Share_Prepared := True;
      transition
         goto WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PREPARE_CH_KEY_SHARE;

      state WAIT_SH_PREPARE_CH_COOKIE
         with Desc => "rfc8446.txt+2223:19-2225:47"
      is
      begin
         Extensions_List'Append ([for E in Server_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_COOKIE => TLS_Handshake::CH_Extension'(Tag => E.Tag, Data_Length => E.Data_Length, Data => E.Data)]'Head);
         CH_Cookie_Prepared := True;
      transition
         goto WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PREPARE_CH_COOKIE;

      state WAIT_SH_PREPARE_CH_PSK
         with Desc => "rfc8446.txt+1519:7-1520:51"
      is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_PSKS, Length => Connection'Size, Payload => Connection));
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS::KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS::KEYSTORE_REQUEST_PSKS
               or (Keystore_Message.Length = 0
                   and TLS_Handshake::PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes_Modes)
               or GreenTLS::PSK_Message (Keystore_Message.Payload)'Valid = False
         goto WAIT_SH_NO_PSK_EXTENSION
            if Keystore_Message.Length = 0
         goto WAIT_SH_PSK_EXTENSION_CHECK
      end WAIT_SH_PREPARE_CH_PSK;

      state WAIT_SH_PSK_EXTENSION_CHECK is
      begin
         PSKs := [for K in GreenTLS::PSK_Message (Keystore_Message.Payload).PSKs if K.Cipher_Suite = Server_Hello_Message.Cipher_Suite => K];
         Binders_Length := Calculate_Binders_Length (PSKs);
         PSK_Identities := [for K in PSKs => TLS_Handshake::PSK_Identity'(Length => K.Identity_Length, Identity => K.Identity_Identity, Obfuscated_Ticket_Age => K.Identity_Obfuscated_Ticket_Age)];
         Pre_Shared_Key_CH := TLS_Handshake::Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Size, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => []);
      transition
         goto ERROR_INTERNAL_ERROR
            if Pre_Shared_Key_CH'Valid = False
         goto WAIT_SH_PSK_EXTENSIONS
      end WAIT_SH_PSK_EXTENSION_CHECK;

      state WAIT_SH_PSK_EXTENSIONS is
         PSK_Key_Exchange_Modes_Extension : TLS_Handshake::CH_Extension;
         Client_Hello_Hash : Hash_Context;
      begin
         PSK_Key_Exchange_Modes_Extension := TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Size, Data => Modes)
            where Modes = TLS_Handshake::PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes_Modes);
         Extensions_List'Append (PSK_Key_Exchange_Modes_Extension);
         Extensions_List'Append (TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_PRE_SHARED_KEY, Data_Length => Pre_Shared_Key_CH'Size, Data => Pre_Shared_Key_CH));
         Client_Hello_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CLIENT_HELLO, Length => CH'Size, Payload => CH)
            where CH = TLS_Handshake::Client_Hello'(Legacy_Version => TLS_Handshake::TLS_1_2, Random => Random_Message.Data, Legacy_Session_ID_Length => 0, Legacy_Session_ID => [], Cipher_Suites_Length => Configuration.Cipher_Suites'Size, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Legacy_Compression_Methods => [], Extensions_Length => Extensions_List'Size, Extensions => Extensions_List);
         Client_Hello_Hash := Empty_Hash;
         Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash));
         Extensions_List := [for E in Extensions_List if E.Tag /= TLS_Handshake::EXTENSION_PRE_SHARED_KEY => E];
         Extensions_List'Append (TLS_Handshake::CH_Extension'(Tag => TLS_Handshake::EXTENSION_PRE_SHARED_KEY, Data_Length => PSK_CH'Size, Data => PSK_CH)
            where PSK_CH = TLS_Handshake::Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Size, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => Binders));
         CH_PSK_Prepared := True;
      transition
         goto ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         goto WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PSK_EXTENSIONS;

      state WAIT_SH_NO_PSK_EXTENSION is
      begin
         CH_PSK_Prepared := True;
      transition
         goto WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_NO_PSK_EXTENSION;

      state WAIT_SH_SEND_CH
         with Desc => "rfc8446.txt+3264:4-3275:42"
      is
         Random : GreenTLS::Content;
         Transcript_Hash_2 : Hash_Context;
      begin
         Transcript_Hash_2 := Empty_Hash;
         Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_MESSAGE_HASH, Length => CH1_Hash'Size, Payload => CH1_Hash.Data)'Opaque)
            where CH1_Hash = Get_Hash (Client_Hello_1_Hash);
         Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Server_Hello_Handshake_Message'Opaque);
         Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Random := GreenTLS::Content'(Data => Client_Hello_Message.Random);
         Client_Hello_Handshake_Message'Reset;
         Client_Hello_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CLIENT_HELLO, Length => CH'Size, Payload => CH)
            where CH = TLS_Handshake::Client_Hello'(Legacy_Version => TLS_Handshake::TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Legacy_Session_ID => [], Cipher_Suites_Length => Configuration.Cipher_Suites'Size, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Legacy_Compression_Methods => [], Extensions_Length => Extensions_List'Size, Extensions => Extensions_List);
         Record_Data_Channel'Write (Client_Hello_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto WAIT_SH
      end WAIT_SH_SEND_CH;

      state SET_RECORD_KEYS is
         Derived_Early_Secret : GreenTLS::Content;
         Handshake_Secret : GreenTLS::Content;
         Server_Key : GreenTLS::Content;
         Server_IV : GreenTLS::Content;
         Client_Key : GreenTLS::Content;
         Client_IV : GreenTLS::Content;
         Success_Client : Boolean;
         Success_Server : Boolean;
      begin
         Derived_Early_Secret := Derive_Secret (Early_Secret, "derived", Get_Hash (Empty_Hash));
         Early_Secret'Reset;
         Handshake_Secret := HKDF_Extract (Derived_Early_Secret, Key)
            where Key = Calculate_ECDHE_Key (Client_Share, TLS_Handshake::Key_Share_SH ([for E in Server_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE => E]'Head.Data))
                     where Client_Share = [for S in TLS_Handshake::Key_Share_CH ([for E in Client_Hello_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE => E]'Head.Data).Shares if S.Group = Selected_Group => S]'Head;
         Derived_Early_Secret'Reset;
         Client_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "c hs traffic", Get_Hash (Transcript_Hash));
         Server_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "s hs traffic", Get_Hash (Transcript_Hash));
         -- FIXME: Replace 256 by key length and IV length determined by keystore
         Server_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Handshake_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Server_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Handshake_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Client_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Handshake_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Client_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Handshake_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_CLIENT, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Key_Update_Message'(Key_Length => Client_Key'Size, Key => Client_Key.Data, IV_Length => Client_IV'Size, IV => Client_IV.Data));
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_SERVER, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Key_Update_Message'(Key_Length => Server_Key'Size, Key => Server_Key.Data, IV_Length => Server_IV'Size, IV => Server_IV.Data));
         Server_Handshake_Traffic_Secret'Reset;
         Server_Key'Reset;
         Server_IV'Reset;
         Client_Key'Reset;
         Client_IV'Reset;
         Derived_Handshake_Secret := Derive_Secret (Handshake_Secret, "derived", Get_Hash (Empty_Hash));
         Handshake_Secret'Reset;
      transition
         goto ERROR_INTERNAL_ERROR
            if Success_Client = False
               or Success_Server = False
         goto WAIT_EE
      end SET_RECORD_KEYS;

      state WAIT_EE is
      begin
         Record_Data_Channel'Read (Encrypted_Extensions_Handshake_Message);
      transition
         goto ERROR_DECODE_ERROR
            if Encrypted_Extensions_Handshake_Message'Valid = False
         goto ERROR_UNEXPECTED_MESSAGE
            if Encrypted_Extensions_Handshake_Message.Tag /= TLS_Handshake::HANDSHAKE_ENCRYPTED_EXTENSIONS
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE;

      state WAIT_EE_PARSE_EXTENSIONS is
      begin
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if (for some E in Encrypted_Extensions_Message.Extensions =>
                   E.Tag = TLS_Handshake::EXTENSION_STATUS_REQUEST
                   or E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS
                   or E.Tag = TLS_Handshake::EXTENSION_SIGNED_CERTIFICATE_TIMESTAMP
                   or E.Tag = TLS_Handshake::EXTENSION_PADDING
                   or E.Tag = TLS_Handshake::EXTENSION_KEY_SHARE
                   or E.Tag = TLS_Handshake::EXTENSION_PRE_SHARED_KEY
                   or E.Tag = TLS_Handshake::EXTENSION_PSK_KEY_EXCHANGE_MODES
                   or E.Tag = TLS_Handshake::EXTENSION_COOKIE
                   or E.Tag = TLS_Handshake::EXTENSION_SUPPORTED_VERSIONS
                   or E.Tag = TLS_Handshake::EXTENSION_CERTIFICATE_AUTHORITIES
                   or E.Tag = TLS_Handshake::EXTENSION_OID_FILTERS
                   or E.Tag = TLS_Handshake::EXTENSION_POST_HANDSHAKE_AUTH
                   or E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS_CERT)
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc6066.txt+376:46-378:16"
            if Server_Name_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SERVER_NAME)
               and Configuration.Server_Name_Enabled = False
         goto WAIT_EE_PROCESS_SERVER_NAME
            if Server_Name_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SERVER_NAME)
         goto WAIT_EE_PROCESS_MAX_FRAGMENT_LENGTH
            if Max_Fragment_Length_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_MAX_FRAGMENT_LENGTH)
         goto WAIT_EE_PROCESS_SUPPORTED_GROUPS
            if Supported_Groups_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SUPPORTED_GROUPS)
         goto WAIT_EE_PROCESS_HEARTBEAT
            if Heartbeat_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_HEARTBEAT)
         goto WAIT_EE_PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
            if Application_Layer_Protocol_Negotiation_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION)
         goto WAIT_EE_PROCESS_EARLY_DATA
            if Early_Data_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_EARLY_DATA)
         goto WAIT_EE_CHECK_EXTENSIONS
      end WAIT_EE_PARSE_EXTENSIONS;

      state WAIT_EE_PROCESS_SERVER_NAME is
      begin
         Server_Name_Extension := [for E in Encrypted_Extensions_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SERVER_NAME => E]'Head;
         Server_Name_Received := True;
      transition
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc6066.txt+378:19-379:9"
            if Server_Name_Extension.Data_Length > 0
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_SERVER_NAME;

      state WAIT_EE_PROCESS_MAX_FRAGMENT_LENGTH is
      begin
         Max_Fragment_Length := TLS_Handshake::Max_Fragment_Length ([for E in Encrypted_Extensions_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_MAX_FRAGMENT_LENGTH => E]'Head.Data).Max_Fragment_Length;
         Max_Fragment_Length_Received := True;
      transition
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc6066.txt+435:50-438:32"
            if Configuration.Max_Fragment_Length /= Max_Fragment_Length
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_MAX_FRAGMENT_LENGTH;

      state WAIT_EE_PROCESS_SUPPORTED_GROUPS
         with Desc => "rfc8446.txt+2651:4-2661:68"
      is
      begin
         Server_Preferred_Groups := TLS_Handshake::Supported_Groups ([for E in Encrypted_Extensions_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SUPPORTED_GROUPS => E]'Head.Data);
         Supported_Groups_Received := True;
      transition
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_SUPPORTED_GROUPS;

      state WAIT_EE_PROCESS_HEARTBEAT
         with Desc => "rfc6520.txt+138:4-149:61"
      is
         Server_Heartbeat_Mode : TLS_Handshake::Heartbeat_Mode;
      begin
         Server_Heartbeat_Mode := TLS_Handshake::Heartbeat ([for E in Encrypted_Extensions_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_HEARTBEAT => E]'Head.Data).Mode;
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::HEARTBEAT_MODE, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Heartbeat_Control_Message'(Local => Configuration.Heartbeat_Mode, Remote => Server_Heartbeat_Mode));
         Heartbeat_Received := True;
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_HEARTBEAT;

      state WAIT_EE_PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION is
         Protocols : TLS_Handshake::Protocol_Names;
         Protocol : TLS_Handshake::Protocol_Name;
      begin
         Protocols := TLS_Handshake::Protocol_Name_List ([for E in Encrypted_Extensions_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION => E]'Head.Data).Protocol_Name_List;
         Protocol := Protocols'Head;
         Application_Control_Channel'Write (GreenTLS::Application_Control_Message'(Tag => GreenTLS::APPLICATION_PROTOCOL, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Application_Protocol_Message'(Protocol_Length => Protocol.Length, Protocol_Name => Protocol.Name));
         Application_Layer_Protocol_Negotiation_Received := True;
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc7301.txt+181:53-185:30"
            if Protocols'Size /= 1
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc7301.txt+175:4-177:54"
            if (for all P in Configuration.Protocols_Protocol_Name_List =>
                   P.Name /= Protocol.Name)
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION;

      state WAIT_EE_PROCESS_EARLY_DATA
         with Desc => "rfc8446.txt+2993:7-2998:45"
      is
      begin
         Early_Data_Received := True;
      transition
         goto WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_EARLY_DATA;

      state WAIT_EE_CHECK_EXTENSIONS is
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, Encrypted_Extensions_Handshake_Message'Opaque);
      transition
         goto ERROR_MISSING_EXTENSION
            if Configuration.Server_Name_Enabled = True
               and Server_Name_Received = False
         goto ERROR_MISSING_EXTENSION
            if Configuration.Max_Fragment_Length_Enabled = True
               and Max_Fragment_Length_Received = False
         goto WAIT_EE_NO_EARLY_DATA
            if Configuration.Early_Data_Enabled = True
               and Early_Data_Received = False
         goto WAIT_EE_DISPATCH
      end WAIT_EE_CHECK_EXTENSIONS;

      state WAIT_EE_NO_EARLY_DATA is
      begin
         Application_Control_Channel'Write (GreenTLS::Application_Control_Message'(Tag => GreenTLS::APPLICATION_NO_EARLY_DATA, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Application_No_Early_Data_Message'(null message));
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto WAIT_EE_DISPATCH
      end WAIT_EE_NO_EARLY_DATA;

      state WAIT_EE_DISPATCH is
      begin
      transition
         goto WAIT_CERT_CR
            if DHE_Accepted = True
         goto WAIT_FINISHED
      end WAIT_EE_DISPATCH;

      state WAIT_CERT_CR is
      begin
         Record_Data_Channel'Read (CCR_Handshake_Message);
         Certificate_Authorities := TLS_Handshake::Certificate_Authorities'(Length => 0, Authorities => []);
         OID_Filters := TLS_Handshake::OID_Filters'(Length => 0, Filters => []);
         Signature_Algorithms := TLS_Handshake::Signature_Algorithms'(Length => 0, Algorithms => []);
         Signature_Algorithms_Cert := TLS_Handshake::Signature_Algorithms_Cert'(Length => 0, Algorithms => []);
      transition
         goto ERROR_DECODE_ERROR
            if CCR_Handshake_Message'Valid = False
         goto ERROR_UNEXPECTED_MESSAGE
            if CCR_Handshake_Message.Tag /= TLS_Handshake::HANDSHAKE_CERTIFICATE
               and CCR_Handshake_Message.Tag /= TLS_Handshake::HANDSHAKE_CERTIFICATE_REQUEST
         goto PARSE_CERT
            if Certificate_Message'Valid = True
         goto PARSE_CR
            if Certificate_Request_Message'Valid = True
         goto ERROR_DECODE_ERROR
      end WAIT_CERT_CR;

      state PARSE_CR is
      begin
         Certificate_Request := TLS_Handshake::Certificate_Request'(Certificate_Request_Context_Length => Certificate_Request_Message.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request_Message.Certificate_Request_Context, Extensions_Length => Certificate_Request_Message.Extensions_Length, Extensions => Certificate_Request_Message.Extensions);
      transition
         goto PARSE_CR_EXTENSIONS
      end PARSE_CR;

      state PARSE_CR_EXTENSIONS is
      begin
         Certificate_Request_Received := True;
      transition
         goto PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES
            if Certificate_Authorities_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_CERTIFICATE_AUTHORITIES)
         goto PARSE_CR_PARSE_OID_FILTERS
            if OID_Filters_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_OID_FILTERS)
         goto PARSE_CR_PARSE_SIGNATURE_ALGORITHMS
            if Signature_Algorithms_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS)
         goto PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT
            if Signature_Algorithms_Cert_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS_CERT)
         goto PARSE_CR_CHECK_EXTENSIONS
      end PARSE_CR_EXTENSIONS;

      state PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES is
      begin
         Certificate_Authorities_Received := True;
         Certificate_Authorities := TLS_Handshake::Certificate_Authorities ([for E in Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_CERTIFICATE_AUTHORITIES => E]'Head.Data);
      transition
         goto PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES;

      state PARSE_CR_PARSE_OID_FILTERS is
      begin
         OID_Filters_Received := True;
         OID_Filters := TLS_Handshake::OID_Filters ([for E in Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_OID_FILTERS => E]'Head.Data);
      transition
         goto PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_OID_FILTERS;

      state PARSE_CR_PARSE_SIGNATURE_ALGORITHMS is
      begin
         Signature_Algorithms_Received := True;
         Signature_Algorithms := TLS_Handshake::Signature_Algorithms ([for E in Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS => E]'Head.Data);
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms_Algorithms =>
                   A not in Signature_Algorithms.Algorithms)
         goto PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_SIGNATURE_ALGORITHMS;

      state PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT is
      begin
         Signature_Algorithms_Cert_Received := True;
         Signature_Algorithms_Cert := TLS_Handshake::Signature_Algorithms_Cert ([for E in Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS_CERT => E]'Head.Data);
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms_Cert_Algorithms =>
                   A not in Signature_Algorithms_Cert.Algorithms)
         goto PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT;

      state PARSE_CR_CHECK_EXTENSIONS is
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque);
      transition
         goto ERROR_MISSING_EXTENSION
            if Signature_Algorithms_Received = False
         goto WAIT_CERT
      end PARSE_CR_CHECK_EXTENSIONS;

      state WAIT_CERT is
      begin
         Record_Data_Channel'Read (CCR_Handshake_Message);
      transition
         goto ERROR_DECODE_ERROR
            if CCR_Handshake_Message'Valid = False
               or Certificate_Message'Valid = False
         goto ERROR_UNEXPECTED_MESSAGE
            if CCR_Handshake_Message.Tag /= TLS_Handshake::HANDSHAKE_CERTIFICATE
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+3593:22-3594:38"
            if Certificate_Message.Certificate_Request_Context_Length /= 0
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+3649:4-3649:58"
            if Certificate_Message.Certificate_List_Length = 0
         goto PARSE_CERT
      end WAIT_CERT;

      state PARSE_CERT is
         Validation_Result : GreenTLS::Certificate_Validation_Result;
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque);
         Validation_Result := Validate_Server_Certificate (Certificate_Message, Configuration, Connection);
      transition
         goto WAIT_CV
            if Validation_Result = GreenTLS::VALID_CERTIFICATE
         goto ERROR_BAD_CERTIFICATE
            if Validation_Result = GreenTLS::BAD_CERTIFICATE
         goto ERROR_UNSUPPORTED_CERTIFICATE
            if Validation_Result = GreenTLS::UNSUPPORTED_CERTIFICATE
         goto ERROR_CERTIFICATE_REVOKED
            if Validation_Result = GreenTLS::CERTIFICATE_REVOKED
         goto ERROR_CERTIFICATE_EXPIRED
            if Validation_Result = GreenTLS::CERTIFICATE_EXPIRED
         goto ERROR_CERTIFICATE_UNKNOWN
            if Validation_Result = GreenTLS::CERTIFICATE_UNKNOWN
         goto ERROR_INTERNAL_ERROR
      end PARSE_CERT;

      state WAIT_CV is
      begin
         Record_Data_Channel'Read (Certificate_Verify_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Certificate_Verify_Handshake_Message'Opaque);
      transition
         goto ERROR_DECODE_ERROR
            if Certificate_Verify_Handshake_Message'Valid = False
               or Certificate_Verify_Message'Valid = False
         goto ERROR_ILLEGAL_PARAMETER
            with Desc => "rfc8446.txt+3902:4-3904:12"
            if Certificate_Verify_Message.Algorithm not in Configuration.Signature_Algorithms_Algorithms
         goto WAIT_CV_VALIDATE
      end WAIT_CV;

      state WAIT_CV_VALIDATE is
         Validation_Result : GreenTLS::Signature_Validation_Result;
      begin
         Validation_Result := Validate_Certificate_Verify_Signature (Certificate_Message, Certificate_Verify_Message, Get_Hash (Transcript_Hash));
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if Validation_Result = GreenTLS::ILLEGAL_PARAMETER
         goto ERROR_DECRYPT_ERROR
            if Validation_Result = GreenTLS::DECRYPT_ERROR
         goto WAIT_FINISHED
            if Validation_Result = GreenTLS::VALID_SIGNATURE
         goto ERROR_INTERNAL_ERROR
      end WAIT_CV_VALIDATE;

      state WAIT_FINISHED is
         Verify_Data : GreenTLS::Content;
         Master_Secret : GreenTLS::Content;
      begin
         Hash_Length := Get_Hash_Length (Server_Hello_Message.Cipher_Suite);
         Record_Data_Channel'Read (Finished_Handshake_Message);
         Finished_Key := HKDF_Expand_Label (Client_Handshake_Traffic_Secret, "finished", Get_Hash (Empty_Hash), Hash_Length);
         Client_Handshake_Traffic_Secret'Reset;
         Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash));
         Transcript_Hash := Update_Hash (Transcript_Hash, Finished_Handshake_Message'Opaque);
         Master_Secret := HKDF_Extract (Derived_Handshake_Secret, Get_Zero_Content (Hash_Length));
         Derived_Handshake_Secret'Reset;
         Client_Application_Traffic_Secret := Derive_Secret (Master_Secret, "c ap traffic", Get_Hash (Transcript_Hash));
         Server_Application_Traffic_Secret := Derive_Secret (Master_Secret, "s ap traffic", Get_Hash (Transcript_Hash));
         Resumption_Master_Secret := Derive_Secret (Master_Secret, "res master", Get_Hash (Transcript_Hash));
         Master_Secret'Reset;
      transition
         goto ERROR_DECRYPT_ERROR
            with Desc => "rfc8446.txt+3951:4-3953:25"
            if Finished_Handshake_Message'Valid = False
               or Finished_Message'Valid = False
               or Finished_Message.Verify_Data /= Verify_Data.Data
         goto SEND_END_OF_EARLY_DATA
            with Desc => "rfc8446.txt+4025:4-4027:19"
            if Early_Data_Received = True
         goto CHECK_CERTIFICATE_REQUEST
            with Desc => "rfc8446.txt+4027:22-4029:26"
      end WAIT_FINISHED;

      state SEND_END_OF_EARLY_DATA is
      begin
         Record_Data_Channel'Write (TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_END_OF_EARLY_DATA, Length => 0, Payload => []));
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto CHECK_CERTIFICATE_REQUEST
      end SEND_END_OF_EARLY_DATA;

      state CHECK_CERTIFICATE_REQUEST is
      begin
      transition
         goto SEND_FINISHED
            with Desc => "rfc8446.txt+3544:4-3546:19"
            if Certificate_Request_Received = False
         goto QUERY_CERTIFICATES
      end CHECK_CERTIFICATE_REQUEST;

      state QUERY_CERTIFICATES is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_CERTIFICATES, Length => Query'Size, Payload => Query)
            where Query = GreenTLS::Certificate_Query'(Certificate_Authorities_Length => Certificate_Authorities.Length, Certificate_Authorities_Authorities => Certificate_Authorities.Authorities, OID_Filters_Length => OID_Filters.Length, OID_Filters_Filters => OID_Filters.Filters, Signature_Algorithms_Length => Signature_Algorithms.Length, Signature_Algorithms_Algorithms => Signature_Algorithms.Algorithms, Signature_Algorithms_Cert_Length => Signature_Algorithms_Cert.Length, Signature_Algorithms_Cert_Algorithms => Signature_Algorithms_Cert.Algorithms));
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or GreenTLS::Certificate (Keystore_Message.Payload)'Valid = False
         goto SEND_CERTIFICATE
            if GreenTLS::Certificate (Keystore_Message.Payload).Length > 0
         goto SEND_EMPTY_CERTIFICATE
            with Desc => "rfc8446.txt+3456:22-3549:26"
      end QUERY_CERTIFICATES;

      state SEND_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake::Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CERTIFICATE, Length => Certificate'Size, Payload => Certificate)
            where Certificate = TLS_Handshake::Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => C.Length, Certificate_List => C.Certificate_List)
               where C = GreenTLS::Certificate (Keystore_Message.Payload);
         Record_Data_Channel'Write (Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto QUERY_SIGNATURE
            with Desc => "rfc8446.txt+3829:24-3833:11"
      end SEND_CERTIFICATE;

      state SEND_EMPTY_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake::Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CERTIFICATE, Length => Certificate'Size, Payload => Certificate)
            where Certificate = TLS_Handshake::Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => 0, Certificate_List => []);
         Record_Data_Channel'Write (Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto SEND_FINISHED
      end SEND_EMPTY_CERTIFICATE;

      state QUERY_SIGNATURE is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_SIGNATURE, Length => Query'Size, Payload => Query)
            where Query = GreenTLS::Signature_Query'(ID => GreenTLS::Certificate (Keystore_Message.Payload).ID, Length => Hash'Size, Data => Hash)
               where Hash = Get_Hash (Transcript_Hash).Data);
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or TLS_Handshake::Certificate_Verify (Keystore_Message.Payload)'Valid = False
         goto SEND_CERTIFICATE_VERIFY
      end QUERY_SIGNATURE;

      state SEND_CERTIFICATE_VERIFY is
         Client_Certificate_Verify_Handshake_Message : TLS_Handshake::Handshake;
      begin
         Client_Certificate_Verify_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CERTIFICATE_VERIFY, Length => Certificate_Verify'Size, Payload => Certificate_Verify)
            where Certificate_Verify = TLS_Handshake::Certificate_Verify (Keystore_Message.Payload);
         Record_Data_Channel'Write (Client_Certificate_Verify_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Verify_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto SEND_FINISHED
      end SEND_CERTIFICATE_VERIFY;

      state SEND_FINISHED is
         Verify_Data : GreenTLS::Content;
      begin
         Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash));
         Finished_Key'Reset;
         Finished_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_FINISHED, Length => Finished'Size, Payload => Finished)
            where Finished = TLS_Handshake::Finished'(Verify_Data => Verify_Data.Data);
         Record_Data_Channel'Write (Finished_Handshake_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto SEND_APPLICATION_RECORD_KEYS
      end SEND_FINISHED;

      state SEND_APPLICATION_RECORD_KEYS is
         Server_Key : GreenTLS::Content;
         Server_IV : GreenTLS::Content;
         Client_Key : GreenTLS::Content;
         Client_IV : GreenTLS::Content;
         Success_Client : Boolean;
         Success_Server : Boolean;
      begin
         -- FIXME: Replace 256 by key length and IV length determined by keystore
         Server_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Server_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Client_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Client_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_CLIENT, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Key_Update_Message'(Key_Length => Client_Key'Size, Key => Client_Key.Data, IV_Length => Client_IV'Size, IV => Client_IV.Data));
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_SERVER, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Key_Update_Message'(Key_Length => Server_Key'Size, Key => Server_Key.Data, IV_Length => Server_IV'Size, IV => Server_IV.Data));
         Server_Application_Traffic_Secret'Reset;
      transition
         goto ERROR_INTERNAL_ERROR
            if Success_Client = False
               or Success_Server = False
         goto CONNECTED
      end SEND_APPLICATION_RECORD_KEYS;

      state CONNECTED
         with Desc => "rfc8446.txt+4047:4-4049:43"
      is
      begin
         Record_Data_Channel'Read (Post_Handshake_Handshake_Message);
      transition
         goto ERROR_DECODE_ERROR
            if Post_Handshake_Handshake_Message'Valid = False
               or (Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_NEW_SESSION_TICKET
                   and New_Session_Ticket_Message'Valid = False)
               or (Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_CERTIFICATE_REQUEST
                   and PHA_Certificate_Request_Message'Valid = False)
               or (Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_KEY_UPDATE
                   and Key_Update_Message'Valid = False)
         goto CONNECTED_NEW_SESSION_TICKET
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_NEW_SESSION_TICKET
               and New_Session_Ticket_Message'Valid = True
         goto CONNECTED_POST_HANDSHAKE_AUTH
            with Desc => "rfc8446.txt+4193:4-4197:57"
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_CERTIFICATE_REQUEST
               and Configuration.Post_Handshake_Auth_Enabled = True
         goto ERROR_UNEXPECTED_MESSAGE
            with Desc => "rfc8446.txt+4212:4-4214:36"
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_CERTIFICATE_REQUEST
               and Configuration.Post_Handshake_Auth_Enabled = False
         goto CONNECTED_KEY_UPDATE
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake::HANDSHAKE_KEY_UPDATE
         goto ERROR_UNEXPECTED_MESSAGE
      end CONNECTED;

      state CONNECTED_NEW_SESSION_TICKET
         with Desc => "rfc8446.txt+4053:4-4056:65"
      is
         PSK : GreenTLS::Content;
      begin
         PSK := HKDF_Expand_Label (GreenTLS::Content'(Data => Resumption_Master_Secret.Data), "resumption", GreenTLS::Content'(Data => New_Session_Ticket_Message.Ticket_Nonce), Hash_Length);
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_NEW_SESSION_TICKET, Length => NST'Size, Payload => NST)
            where NST = GreenTLS::New_Session_Ticket'(Connection_Name_Length => Connection.Name_Length, Connection_Name => Connection.Name, Connection_Port => Connection.Port, Session_Ticket_Lifetime => New_Session_Ticket_Message.Ticket_Lifetime, Session_Ticket_Age_Add => New_Session_Ticket_Message.Ticket_Age_Add, Session_Ticket_Nonce_Length => New_Session_Ticket_Message.Ticket_Nonce_Length, Session_Ticket_Nonce => New_Session_Ticket_Message.Ticket_Nonce, Session_Ticket_Length => New_Session_Ticket_Message.Ticket_Length, Session_Ticket => New_Session_Ticket_Message.Ticket, Session_Extensions_Length => New_Session_Ticket_Message.Extensions_Length, Session_Extensions => New_Session_Ticket_Message.Extensions, PSK_Length => PSK'Size, PSK => PSK.Data));
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
         goto CONNECTED
      end CONNECTED_NEW_SESSION_TICKET;

      state CONNECTED_POST_HANDSHAKE_AUTH is
      begin
         Certificate_Authorities_Received := False;
         OID_Filters_Received := False;
         Signature_Algorithms_Received := False;
         Signature_Algorithms_Cert_Received := False;
      transition
         goto CONNECTED_PHA_PARSE_CR
      end CONNECTED_POST_HANDSHAKE_AUTH;

      state CONNECTED_PHA_PARSE_CR is
      begin
         Certificate_Request := TLS_Handshake::Certificate_Request'(Certificate_Request_Context_Length => PHA_Certificate_Request_Message.Certificate_Request_Context_Length, Certificate_Request_Context => PHA_Certificate_Request_Message.Certificate_Request_Context, Extensions_Length => PHA_Certificate_Request_Message.Extensions_Length, Extensions => PHA_Certificate_Request_Message.Extensions);
      transition
         goto CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR;

      state CONNECTED_PHA_PARSE_CR_EXTENSIONS is
      begin
      transition
         goto CONNECTED_PHA_PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES
            if Certificate_Authorities_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_CERTIFICATE_AUTHORITIES)
         goto CONNECTED_PHA_PARSE_CR_PARSE_OID_FILTERS
            if OID_Filters_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_OID_FILTERS)
         goto CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS
            if Signature_Algorithms_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS)
         goto CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT
            if Signature_Algorithms_Cert_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS_CERT)
         goto CONNECTED_PHA_PARSE_CR_CHECK_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_EXTENSIONS;

      state CONNECTED_PHA_PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES is
      begin
         Certificate_Authorities_Received := True;
         Certificate_Authorities := TLS_Handshake::Certificate_Authorities ([for E in PHA_Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_CERTIFICATE_AUTHORITIES => E]'Head.Data);
      transition
         goto CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES;

      state CONNECTED_PHA_PARSE_CR_PARSE_OID_FILTERS is
      begin
         OID_Filters_Received := True;
         OID_Filters := TLS_Handshake::OID_Filters ([for E in PHA_Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_OID_FILTERS => E]'Head.Data);
      transition
         goto CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_OID_FILTERS;

      state CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS is
      begin
         Signature_Algorithms_Received := True;
         Signature_Algorithms := TLS_Handshake::Signature_Algorithms ([for E in PHA_Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS => E]'Head.Data);
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms_Algorithms =>
                   A not in Signature_Algorithms.Algorithms)
         goto CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS;

      state CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT is
      begin
         Signature_Algorithms_Cert_Received := True;
         Signature_Algorithms_Cert := TLS_Handshake::Signature_Algorithms_Cert ([for E in PHA_Certificate_Request_Message.Extensions if E.Tag = TLS_Handshake::EXTENSION_SIGNATURE_ALGORITHMS_CERT => E]'Head.Data);
      transition
         goto ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms_Cert_Algorithms =>
                   A not in Signature_Algorithms_Cert.Algorithms)
         goto CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT;

      state CONNECTED_PHA_PARSE_CR_CHECK_EXTENSIONS is
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque);
      transition
         goto ERROR_MISSING_EXTENSION
            if Signature_Algorithms_Received = False
         goto CONNECTED_PHA_QUERY_CERTIFICATES
      end CONNECTED_PHA_PARSE_CR_CHECK_EXTENSIONS;

      state CONNECTED_PHA_QUERY_CERTIFICATES is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_CERTIFICATES, Length => Query'Size, Payload => Query)
            where Query = GreenTLS::Certificate_Query'(Certificate_Authorities_Length => Certificate_Authorities.Length, Certificate_Authorities_Authorities => Certificate_Authorities.Authorities, OID_Filters_Length => OID_Filters.Length, OID_Filters_Filters => OID_Filters.Filters, Signature_Algorithms_Length => Signature_Algorithms.Length, Signature_Algorithms_Algorithms => Signature_Algorithms.Algorithms, Signature_Algorithms_Cert_Length => Signature_Algorithms_Cert.Length, Signature_Algorithms_Cert_Algorithms => Signature_Algorithms_Cert.Algorithms));
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or GreenTLS::Certificate (Keystore_Message.Payload)'Valid = False
         goto CONNECTED_PHA_SEND_CERTIFICATE
            if GreenTLS::Certificate (Keystore_Message.Payload).Length > 0
         goto CONNECTED_PHA_SEND_EMPTY_CERTIFICATE
            with Desc => "rfc8446.txt+3456:22-3549:26"
      end CONNECTED_PHA_QUERY_CERTIFICATES;

      state CONNECTED_PHA_SEND_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake::Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CERTIFICATE, Length => Certificate'Size, Payload => Certificate)
            where Certificate = TLS_Handshake::Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => C.Length, Certificate_List => C.Certificate_List)
                     where C = GreenTLS::Certificate (Keystore_Message.Payload);
         Record_Data_Channel'Write (Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto CONNECTED_PHA_QUERY_SIGNATURE
            with Desc => "rfc8446.txt+3829:24-3833:11"
      end CONNECTED_PHA_SEND_CERTIFICATE;

      state CONNECTED_PHA_SEND_EMPTY_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake::Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CERTIFICATE, Length => Certificate'Size, Payload => Certificate)
            where Certificate = TLS_Handshake::Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => 0, Certificate_List => []);
         Record_Data_Channel'Write (Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto CONNECTED_PHA_SEND_FINISHED
      end CONNECTED_PHA_SEND_EMPTY_CERTIFICATE;

      state CONNECTED_PHA_QUERY_SIGNATURE is
      begin
         Keystore_Channel'Write (GreenTLS::Keystore_Message'(Tag => GreenTLS::KEYSTORE_REQUEST, Request => GreenTLS::KEYSTORE_REQUEST_SIGNATURE, Length => Query'Size, Payload => Query)
            where Query = GreenTLS::Signature_Query'(ID => GreenTLS::Certificate (Keystore_Message.Payload).ID, Length => Hash'Size, Data => Hash)
                     where Hash = Get_Hash (Transcript_Hash).Data);
         Keystore_Channel'Read (Keystore_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or TLS_Handshake::Certificate_Verify (Keystore_Message.Payload)'Valid = False
         goto CONNECTED_PHA_SEND_CERTIFICATE_VERIFY
      end CONNECTED_PHA_QUERY_SIGNATURE;

      state CONNECTED_PHA_SEND_CERTIFICATE_VERIFY is
         Client_Certificate_Verify_Handshake_Message : TLS_Handshake::Handshake;
      begin
         Client_Certificate_Verify_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_CERTIFICATE_VERIFY, Length => Certificate_Verify'Size, Payload => Certificate_Verify)
            where Certificate_Verify = TLS_Handshake::Certificate_Verify (Keystore_Message.Payload);
         Record_Data_Channel'Write (Client_Certificate_Verify_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Verify_Handshake_Message'Opaque);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto CONNECTED_PHA_SEND_FINISHED
      end CONNECTED_PHA_SEND_CERTIFICATE_VERIFY;

      state CONNECTED_PHA_SEND_FINISHED is
         Verify_Data : GreenTLS::Content;
      begin
         Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash));
         Finished_Key'Reset;
         Finished_Handshake_Message := TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_FINISHED, Length => Finished'Size, Payload => Finished)
            where Finished = TLS_Handshake::Finished'(Verify_Data => Verify_Data.Data);
         Record_Data_Channel'Write (Finished_Handshake_Message);
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
         goto CONNECTED
      end CONNECTED_PHA_SEND_FINISHED;

      state CONNECTED_KEY_UPDATE is
         Server_Key : GreenTLS::Content;
         Server_IV : GreenTLS::Content;
         Success_Server : Boolean;
      begin
         Server_Application_Traffic_Secret := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Application_Traffic_Secret.Data), "traffic upd", Get_Hash (Empty_Hash), Hash_Length);
         -- FIXME: Replace 256 by key length and IV length determined by keystore
         Server_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Server_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Server_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_SERVER, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Key_Update_Message'(Key_Length => Server_Key'Size, Key => Server_Key.Data, IV_Length => Server_IV'Size, IV => Server_IV.Data));
      transition
         goto ERROR_INTERNAL_ERROR
            if Success_Server = False
         goto CONNECTED_SEND_KEY_UPDATE
            if Key_Update_Message.Request_Update = TLS_Handshake::UPDATE_REQUESTED
         goto CONNECTED
      end CONNECTED_KEY_UPDATE;

      state CONNECTED_SEND_KEY_UPDATE is
         Client_Key : GreenTLS::Content;
         Client_IV : GreenTLS::Content;
         Success_Client : Boolean;
      begin
         Record_Data_Channel'Write (TLS_Handshake::Handshake'(Tag => TLS_Handshake::HANDSHAKE_KEY_UPDATE, Length => KU'Size, Payload => KU)
            where KU = TLS_Handshake::Key_Update'(Request_Update => TLS_Handshake::UPDATE_NOT_REQUESTED));
         Client_Application_Traffic_Secret := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Application_Traffic_Secret.Data), "traffic upd", Get_Hash (Empty_Hash), Hash_Length);
         -- FIXME: Replace 256 by key length and IV length determined by keystore
         Client_Key := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), 256);
         Client_IV := HKDF_Expand_Label (GreenTLS::Content'(Data => Client_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), 256);
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::KEY_UPDATE_CLIENT, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Key_Update_Message'(Key_Length => Client_Key'Size, Key => Client_Key.Data, IV_Length => Client_IV'Size, IV => Client_IV.Data));
      transition
         goto ERROR_INTERNAL_ERROR
            if Success = False
               or Success_Client = False
         goto CONNECTED
      end CONNECTED_SEND_KEY_UPDATE;

      state ERROR_INVALID_CONFIGURATION is
      begin
         Error := TLS_Alert::ILLEGAL_PARAMETER;
      transition
         goto ERROR_SEND_LOCAL
      end ERROR_INVALID_CONFIGURATION;

      state ERROR_UNEXPECTED_MESSAGE is
      begin
         Error := TLS_Alert::UNEXPECTED_MESSAGE;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_UNEXPECTED_MESSAGE;

      state ERROR_BAD_CERTIFICATE is
      begin
         Error := TLS_Alert::BAD_CERTIFICATE;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_BAD_CERTIFICATE;

      state ERROR_UNSUPPORTED_CERTIFICATE is
      begin
         Error := TLS_Alert::UNSUPPORTED_CERTIFICATE;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_UNSUPPORTED_CERTIFICATE;

      state ERROR_CERTIFICATE_REVOKED is
      begin
         Error := TLS_Alert::CERTIFICATE_REVOKED;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_CERTIFICATE_REVOKED;

      state ERROR_CERTIFICATE_EXPIRED is
      begin
         Error := TLS_Alert::CERTIFICATE_EXPIRED;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_CERTIFICATE_EXPIRED;

      state ERROR_CERTIFICATE_UNKNOWN is
      begin
         Error := TLS_Alert::CERTIFICATE_UNKNOWN;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_CERTIFICATE_UNKNOWN;

      state ERROR_ILLEGAL_PARAMETER is
      begin
         Error := TLS_Alert::ILLEGAL_PARAMETER;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_ILLEGAL_PARAMETER;

      state ERROR_DECODE_ERROR is
      begin
         Error := TLS_Alert::DECODE_ERROR;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_DECODE_ERROR;

      state ERROR_DECRYPT_ERROR is
      begin
         Error := TLS_Alert::DECRYPT_ERROR;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_DECRYPT_ERROR;

      state ERROR_PROTOCOL_VERSION is
      begin
         Error := TLS_Alert::PROTOCOL_VERSION;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_PROTOCOL_VERSION;

      state ERROR_INTERNAL_ERROR is
      begin
         Error := TLS_Alert::INTERNAL_ERROR;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_INTERNAL_ERROR;

      state ERROR_MISSING_EXTENSION is
      begin
         Error := TLS_Alert::MISSING_EXTENSION;
      transition
         goto ERROR_SEND_REMOTE
      end ERROR_MISSING_EXTENSION;

      state ERROR_SEND_REMOTE is
      begin
         Record_Control_Channel'Write (GreenTLS::Control_Message'(Tag => GreenTLS::ALERT, Length => Alert_Message'Size, Data => Alert_Message)
            where Alert_Message = GreenTLS::Alert_Message'(Description => Error));
      transition
         goto ERROR_SEND_LOCAL
      end ERROR_SEND_REMOTE;

      state ERROR_SEND_LOCAL is
      begin
         Application_Control_Channel'Write (GreenTLS::Application_Control_Message'(Tag => GreenTLS::APPLICATION_ALERT, Length => Data'Size, Data => Data)
            where Data = GreenTLS::Alert_Message'(Description => Error));
      transition
         goto TERMINATED
      end ERROR_SEND_LOCAL;

      state TERMINATED is null state;
   end Client;

end TLS_Handshake_Session;
