package TLS_Handshake_Session is

   generic
      Record_Data_Channel : Channel with Readable, Writable;
      Record_Control_Channel : Channel with Writable;
      RNG_Channel : Channel with Readable, Writable;
      Keystore_Channel : Channel with Readable, Writable;
      Application_Control_Channel : Channel with Readable, Writable;
      Configuration_Channel : Channel with Readable;
      Connection_Channel : Channel with Readable;

      type Hash_Context is private;

      with function Calculate_Binders (PSKs : GreenTLS_PSKs; Transcript_Hash : GreenTLS_Content) return TLS_Handshake_PSK_Binder_Entries;
      with function Calculate_Binders_Length (PSKs : GreenTLS_PSKs) return Types_Bit_Length;
      with function Calculate_ECDHE_Key (Client_Share : TLS_Handshake_Key_Share_Entry; Server_Share : TLS_Handshake_Key_Share_Entry) return GreenTLS_Content;
      with function Create_Client_Hello_Extensions (Configuration : GreenTLS_Configuration) return FIXME;
      with function Derive_Secret (Secret : GreenTLS_Content; Label : String; Transcript_Hash : GreenTLS_Content) return GreenTLS_Content;
      with function Empty_Hash return Hash_Context;
      with function Get_Hash (Context : Hash_Context) return GreenTLS_Content;
      with function Get_Hash_Length (Cipher_Suite : TLS_Handshake_Cipher_Suite) return GreenTLS_KM_Length;
      with function Get_Zero_Content (Length : GreenTLS_KM_Length) return GreenTLS_Content;
      with function HKDF_Expand_Label (Secret : GreenTLS_Content; Label : String; Context : GreenTLS_Content; Length : GreenTLS_KM_Length) return GreenTLS_Content;
      with function HKDF_Extract (Salt : GreenTLS_Content; IKM : GreenTLS_Content) return GreenTLS_Content;
      with function HMAC (Cipher_Suite : TLS_Handshake_Cipher_Suite; Key : GreenTLS_Content; Hash : GreenTLS_Content) return GreenTLS_Content;
      with function Select_Supported_Groups (Server_Preferred_Groups : TLS_Handshake_Named_Groups; Supported_Groups : TLS_Handshake_Named_Groups) return TLS_Handshake_Named_Groups;
      with function Truncate_Client_Hello (Client_Hello : TLS_Handshake_Handshake) return GreenTLS_Content;
      with function Update_Hash (Context : Hash_Context; Data : Payload) return Hash_Context;
      with function Validate_Certificate_Verify_Signature (Certificate_Message : TLS_Handshake_Certificate; Certificate_Verify_Message : TLS_Handshake_Certificate_Verify; Transcript_Hash : GreenTLS_Content) return GreenTLS_Signature_Validation_Result;
      with function Validate_Server_Certificate (Certificate_Message : TLS_Handshake_Certificate; Configuration : GreenTLS_Configuration; Connection : GreenTLS_Connection) return GreenTLS_Certificate_Validation_Result;
   session Client with
      Initial => START,
      Final => TERMINATED
   is
      FIXME_NULL : Dummy;
      FIXME : Dummy;
      GreenTLS_APPLICATION_ALERT : Dummy;
      GreenTLS_APPLICATION_NO_EARLY_DATA : Dummy;
      GreenTLS_APPLICATION_PROTOCOL : Dummy;
      GreenTLS_BAD_CERTIFICATE : Dummy;
      GreenTLS_CERTIFICATE_EXPIRED : Dummy;
      GreenTLS_CERTIFICATE_REVOKED : Dummy;
      GreenTLS_CERTIFICATE_UNKNOWN : Dummy;
      GreenTLS_DECRYPT_ERROR : Dummy;
      GreenTLS_HEARTBEAT_MODE : Dummy;
      GreenTLS_ILLEGAL_PARAMETER : Dummy;
      GreenTLS_KEYSTORE_REQUEST : Dummy;
      GreenTLS_KEYSTORE_REQUEST_PSK : Dummy;
      GreenTLS_KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS : Dummy;
      GreenTLS_KEY_UPDATE_CLIENT : Dummy;
      GreenTLS_KEY_UPDATE_SERVER : Dummy;
      GreenTLS_RNG_REQUEST : Dummy;
      GreenTLS_RNG_RESPONSE : Dummy;
      GreenTLS_TLS_1_2 : Dummy;
      GreenTLS_UNSUPPORTED_CERTIFICATE : Dummy;
      GreenTLS_VALID_CERTIFICATE : Dummy;
      GreenTLS_VALID_SIGNATURE : Dummy;
      TLS_Alert_ALERT : Dummy;
      TLS_Alert_BAD_CERTIFICATE : Dummy;
      TLS_Alert_CERTIFICATE_EXPIRED : Dummy;
      TLS_Alert_CERTIFICATE_REVOKED : Dummy;
      TLS_Alert_CERTIFICATE_UNKNOWN : Dummy;
      TLS_Alert_DECODE_ERROR : Dummy;
      TLS_Alert_DECRYPT_ERROR : Dummy;
      TLS_Alert_ILLEGAL_PARAMETER : Dummy;
      TLS_Alert_INTERNAL_ERROR : Dummy;
      TLS_Alert_MISSING_EXTENSION : Dummy;
      TLS_Alert_PROTOCOL_VERSION : Dummy;
      TLS_Alert_UNEXPECTED_MESSAGE : Dummy;
      TLS_Alert_UNSUPPORTED_CERTIFICATE : Dummy;
      TLS_Handshake_EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION : Dummy;
      TLS_Handshake_EXTENSION_CERTIFICATE_AUTHORITIES : Dummy;
      TLS_Handshake_EXTENSION_COOKIE : Dummy;
      TLS_Handshake_EXTENSION_EARLY_DATA : Dummy;
      TLS_Handshake_EXTENSION_HEARTBEAT : Dummy;
      TLS_Handshake_EXTENSION_KEY_SHARE : Dummy;
      TLS_Handshake_EXTENSION_MAX_FRAGMENT_LENGTH : Dummy;
      TLS_Handshake_EXTENSION_OID_FILTERS : Dummy;
      TLS_Handshake_EXTENSION_POST_HANDSHAKE_AUTH : Dummy;
      TLS_Handshake_EXTENSION_PRE_SHARED_KEY : Dummy;
      TLS_Handshake_EXTENSION_PSK_KEY_EXCHANGE_MODES : Dummy;
      TLS_Handshake_EXTENSION_SERVER_NAME : Dummy;
      TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT : Dummy;
      TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS : Dummy;
      TLS_Handshake_EXTENSION_SUPPORTED_GROUPS : Dummy;
      TLS_Handshake_EXTENSION_SUPPORTED_VERSIONS : Dummy;
      TLS_Handshake_HANDSHAKE_CERTIFICATE : Dummy;
      TLS_Handshake_HANDSHAKE_CERTIFICATE_REQUEST : Dummy;
      TLS_Handshake_HANDSHAKE_CERTIFICATE_VERIFY : Dummy;
      TLS_Handshake_HANDSHAKE_CLIENT_HELLO : Dummy;
      TLS_Handshake_HANDSHAKE_ENCRYPTED_EXTENSIONS : Dummy;
      TLS_Handshake_HANDSHAKE_END_OF_EARLY_DATA : Dummy;
      TLS_Handshake_HANDSHAKE_FINISHED : Dummy;
      TLS_Handshake_HANDSHAKE_KEY_UPDATE : Dummy;
      TLS_Handshake_HANDSHAKE_MESSAGE_HASH : Dummy;
      TLS_Handshake_HANDSHAKE_NEW_SESSION_TICKET : Dummy;
      TLS_Handshake_HANDSHAKE_SERVER_HELLO : Dummy;
      TLS_Handshake_PSK_DHE_KE : Dummy;
      TLS_Handshake_PSK_KE : Dummy;
      TLS_Handshake_TLS_1_3 : Dummy;
      TLS_Handshake_UPDATE_REQUESTED : Dummy;
      GreenTLS_Certificate : Dummy;
      GreenTLS_KEYSTORE_REQUEST_CERTIFICATES : Dummy;
      GreenTLS_KEYSTORE_REQUEST_NEW_SESSION_TICKET : Dummy;
      GreenTLS_KEYSTORE_REQUEST_PSK_IDENTITIES : Dummy;
      GreenTLS_KEYSTORE_REQUEST_PSKS : Dummy;
      GreenTLS_KEYSTORE_REQUEST_SIGNATURE : Dummy;
      GreenTLS_KEYSTORE_RESPONSE : Dummy;
      GreenTLS_PSK : Dummy;
      GreenTLS_PSK_Message : Dummy;
      GreenTLS_TLS_1_3 : Dummy;
      TLS_Handshake_Certificate_Authorities : Dummy;
      TLS_Handshake_Certificate_Verify : Dummy;
      TLS_Handshake_Client_Hello : Dummy;
      TLS_Handshake_EXTENSION_PADDING : Dummy;
      TLS_Handshake_Heartbeat : Dummy;
      TLS_Handshake_Key_Share_CH : Dummy;
      TLS_Handshake_Key_Share_Entry : Dummy;
      TLS_Handshake_Key_Share_HRR : Dummy;
      TLS_Handshake_Key_Share_SH : Dummy;
      TLS_Handshake_Max_Fragment_Length : Dummy;
      TLS_Handshake_OID_Filters : Dummy;
      TLS_Handshake_Pre_Shared_Key_CH : Dummy;
      TLS_Handshake_Pre_Shared_Key_SH : Dummy;
      TLS_Handshake_Protocol_Name_List : Dummy;
      TLS_Handshake_Signature_Algorithms_Cert : Dummy;
      TLS_Handshake_Signature_Algorithms : Dummy;
      TLS_Handshake_Supported_Groups : Dummy;
      TLS_Handshake_TLS_1_2 : Dummy;
      TLS_Handshake_UPDATE_NOT_REQUESTED : Dummy;
      TLS_Handshake_EXTENSION_SIGNED_CERTIFICATE_TIMESTAMP : Dummy;
      TLS_Handshake_Supported_Versions : Dummy;
      TLS_Handshake_EXTENSION_STATUS_REQUEST : Dummy;

      Application_Layer_Protocol_Negotiation_Received : Boolean := False;
      Binders : TLS_Handshake_PSK_Binder_Entries;
      Binders_Length : TLS_Handshake_Binders_Length;
      CCR_Handshake_Message : TLS_Handshake_Handshake;
      CH_Cookie_Prepared : Boolean := False;
      CH_Key_Share_Prepared : Boolean := False;
      CH_PSK_Prepared : Boolean := False;
      Certificate_Authorities : TLS_Handshake_Certificate_Authorities;
      Certificate_Authorities_Received : Boolean := False;
      Certificate_Request : TLS_Handshake_Certificate_Request;
      Certificate_Request_Received : Boolean := False;
      Certificate_Verify_Handshake_Message : TLS_Handshake_Handshake;
      Client_Application_Traffic_Secret : GreenTLS_Content;
      Client_Handshake_Traffic_Secret : GreenTLS_Content;
      Client_Hello_1_Hash : Hash_Context;
      Client_Hello_Handshake_Message : TLS_Handshake_Handshake;
      Client_Shares : TLS_Handshake_Key_Share_Entries;
      Configuration : GreenTLS_Configuration;
      Connection : GreenTLS_Connection;
      DHE_Accepted : Boolean := False;
      Derived_Handshake_Secret : GreenTLS_Content;
      Early_Data_Received : Boolean := False;
      Early_Secret : GreenTLS_Content;
      Encrypted_Extensions_Handshake_Message : TLS_Handshake_Handshake;
      Error : TLS_Alert_Alert_Description;
      Extensions_List : TLS_Handshake_Extensions;
      Finished_Key : GreenTLS_Content;
      Finished_Handshake_Message : TLS_Handshake_Handshake;
      Hash_Length : GreenTLS_KM_Length;
      Heartbeat_Received : Boolean := False;
      Identity_Index : TLS_Handshake_Identity_Index;
      Keystore_Message : GreenTLS_Keystore_Message;
      Max_Fragment_Length : TLS_Handshake_Max_Fragment_Length_Value;
      Max_Fragment_Length_Received : Boolean := False;
      OID_Filters : TLS_Handshake_OID_Filters;
      OID_Filters_Received : Boolean := False;
      PSK_Identities : TLS_Handshake_PSK_Identities;
      PSKs : GreenTLS_PSKs;
      Post_Handshake_Handshake_Message : TLS_Handshake_Handshake;
      Random_Message : GreenTLS_RNG_Message;
      Pre_Shared_Key_CH : TLS_Handshake_Pre_Shared_Key_CH;
      Resumption_Master_Secret : GreenTLS_Content;
      Retry_Request_Received : Boolean := False;
      Selected_Group : TLS_Handshake_Named_Group;
      Server_Application_Traffic_Secret : GreenTLS_Content;
      Server_Handshake_Traffic_Secret : GreenTLS_Content;
      Server_Hello_Handshake_Message : TLS_Handshake_Handshake;
      Server_Name_Extension : TLS_Handshake_Extension;
      Server_Name_Received : Boolean := False;
      Server_Preferred_Groups : TLS_Handshake_Supported_Groups;
      Signature_Algorithms : TLS_Handshake_Signature_Algorithms;
      Signature_Algorithms_Cert : TLS_Handshake_Signature_Algorithms;
      Signature_Algorithms_Cert_Received : Boolean := False;
      Signature_Algorithms_Received : Boolean := False;
      Success : Boolean;
      Supported_Groups : TLS_Handshake_Named_Groups;
      Supported_Groups_Received : Boolean := False;
      Transcript_Hash : Hash_Context;

      Certificate_Message : TLS_Handshake_Certificate renames CCR_Handshake_Message.Payload;
      Certificate_Request_Message : TLS_Handshake_Certificate_Request renames CCR_Handshake_Message.Payload;
      Certificate_Verify_Message : TLS_Handshake_Certificate_Verify renames Certificate_Verify_Handshake_Message.Payload;
      Client_Hello_Message : TLS_Handshake_Client_Hello renames Client_Hello_Handshake_Message.Payload;
      Encrypted_Extensions_Message : TLS_Handshake_Encrypted_Extensions renames Encrypted_Extensions_Handshake_Message.Payload;
      Finished_Message : TLS_Handshake_Finished renames Finished_Handshake_Message.Payload;
      Key_Update_Message : TLS_Handshake_Key_Update renames Post_Handshake_Handshake_Message.Payload;
      New_Session_Ticket_Message : TLS_Handshake_New_Session_Ticket renames Post_Handshake_Handshake_Message.Payload;
      PHA_Certificate_Request_Message : TLS_Handshake_Certificate_Request renames Post_Handshake_Handshake_Message.Payload;
      Server_Hello_Message : TLS_Handshake_Server_Hello renames Server_Hello_Handshake_Message.Payload;
   begin
      state START is
      begin
         Connection := Read (Connection_Channel);
         Configuration := Read (Configuration_Channel);
      transition
         then ERROR_INTERNAL_ERROR
            if Connection'Valid = False
         then ERROR_INTERNAL_ERROR
            if Configuration'Valid = False
         then SERVER_PREFERRED_GROUPS
      end START;

      state SERVER_PREFERRED_GROUPS is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS));
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS_KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS_KEYSTORE_REQUEST_SERVER_PREFERRED_GROUPS
         then SERVER_PREFERRED_GROUPS_CONFIGURE
      end SERVER_PREFERRED_GROUPS;

      state SERVER_PREFERRED_GROUPS_CONFIGURE is
      begin
         Server_Preferred_Groups := TLS_Handshake_Supported_Groups (Keystore_Message.Payload);
      transition
         then ERROR_INTERNAL_ERROR
            if Server_Preferred_Groups'Valid = False
         then SERVER_PREFERRED_GROUPS_SELECT
      end SERVER_PREFERRED_GROUPS_CONFIGURE;

      state SERVER_PREFERRED_GROUPS_SELECT is
      begin
         Supported_Groups := Select_Supported_Groups (Server_Preferred_Groups.Supported_Groups, Configuration.Supported_Groups);
      transition
         then CREATE_CLIENT_HELLO_EXTENSIONS
      end SERVER_PREFERRED_GROUPS_SELECT;

      state CREATE_CLIENT_HELLO_EXTENSIONS is
         Supported_Version : TLS_Handshake_Supported_Version;
         Supported_Versions_Extension : TLS_Handshake_CH_Extension;
      begin
         Supported_Version := TLS_Handshake_Supported_Version'(Version => TLS_Handshake_TLS_1_3);
         Supported_Versions_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_SUPPORTED_VERSIONS, Data_Length => Supported_Version'Length, Data => Supported_Version);
         Extensions_List := Append (Extensions_List, Supported_Versions_Extension);
         Extensions_List := Extend (Extensions_List, Create_Client_Hello_Extensions (Configuration));
      transition
         then ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         then START_POST_HANDSHAKE_AUTH_EXTENSION
            if Configuration.Post_Handshake_Auth_Enabled = True
         then START_DHE
            if TLS_Handshake_PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes
         then START_PSK
            if TLS_Handshake_PSK_KE in Configuration.PSK_Key_Exchange_Modes
         then ERROR_INTERNAL_ERROR
      end CREATE_CLIENT_HELLO_EXTENSIONS;

      state START_POST_HANDSHAKE_AUTH_EXTENSION is
         Post_Handshake_Auth_Extension : TLS_Handshake_CH_Extension;
      begin
         Post_Handshake_Auth_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_POST_HANDSHAKE_AUTH, Data_Length => 0);
         Extensions_List := Append (Extensions_List, Post_Handshake_Auth_Extension);
      transition
         then ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         then START_DHE
            if TLS_Handshake_PSK_DHE_KE in Configuration.PSK_Key_Exchange_Modes
         then START_PSK
            if TLS_Handshake_PSK_KE in Configuration.PSK_Key_Exchange_Modes
         then ERROR_INTERNAL_ERROR
      end START_POST_HANDSHAKE_AUTH_EXTENSION;

      state START_DHE is
         Supported_Groups_Extension : TLS_Handshake_CH_Extension;
         Key_Share_Extension : TLS_Handshake_CH_Extension;
         Signature_Algorithms_Extension : TLS_Handshake_CH_Extension;
      begin
         Supported_Groups_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_SUPPORTED_GROUPS, Data_Length => Modes'Length, Data => Modes)
            where Modes = TLS_Handshake_Supported_Groups'(Length => Configuration.Supported_Groups_Length, Groups => Configuration.Supported_Groups);
         Extensions_List := Append (Extensions_List, Supported_Groups_Extension);
         Key_Share_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_KEY_SHARE, Data_Length => Modes'Length, Data => Modes)
            where Modes = TLS_Handshake_Key_Share'(Length => Configuration.Key_Shares_Length, Shares => Configuration.Key_Shares);
         Extensions_List := Append (Extensions_List, Key_Share_Extension);
         Signature_Algorithms_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS, Data_Length => Modes'Length, Data => Modes)
            where Modes = TLS_Handshake_Signature_Algorithms'(Length => Configuration.Signature_Algorithms_Length, Algorithms => Configuration.Signature_Algorithms);
         Extensions_List := Append (Extensions_List, Signature_Algorithms_Extension);
      transition
         then ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         then START_DHE_SIGNATURE_ALGORITHMS
            if Configuration.Server_Authentication_Enabled = True
         then START_PSK
            if TLS_Handshake_PSK_KE in Configuration.PSK_Key_Exchange_Modes
         then START_SEND
      end START_DHE;

      state START_DHE_SIGNATURE_ALGORITHMS is
         Signature_Algorithms_Cert_Extension : TLS_Handshake_CH_Extension;
      begin
         Signature_Algorithms_Cert_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT, Data_Length => Modes'Length, Data => Modes)
            where Modes = TLS_Handshake_Signature_Algorithms_Cert'(Length => Configuration.Signature_Algorithms_Cert_Length, Algorithms => Configuration.Signature_Algorithms_Cert);
         Extensions_List := Append (Extensions_List, Signature_Algorithms_Cert_Extension);
      transition
         then ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         then START_PSK
            if TLS_Handshake_PSK_KE in Configuration.PSK_Key_Exchange_Modes
         then START_SEND
      end START_DHE_SIGNATURE_ALGORITHMS;

      state START_PSK is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_PSKS, Length => Connection'Length, Payload => Connection));
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS_KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS_KEYSTORE_REQUEST_PSK_IDENTITIES
               or (Keystore_Message.Length = 0
                   and TLS_Handshake_PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes)
         then START_SEND
            if Keystore_Message.Length = 0
         then START_PSK_EXTENSION_CHECK
      end START_PSK;

      state START_PSK_EXTENSION_CHECK is
      begin
         PSKs := GreenTLS_PSK_Message (Keystore_Message.Payload).PSKs;
         Binders_Length := Calculate_Binders_Length (PSKs);
         PSK_Identities := [for K in PSKs => K.Identity when True];
         Pre_Shared_Key_CH := TLS_Handshake_Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => FIXME_NULL);
      transition
         then ERROR_INTERNAL_ERROR
            if Pre_Shared_Key_CH'Valid = False
         then START_GET_RANDOM
      end START_PSK_EXTENSION_CHECK;

      state START_GET_RANDOM is
      begin
         Random_Message := Call (RNG_Channel, GreenTLS_RNG_Message'(Tag => GreenTLS_RNG_REQUEST, Length => 32));
      transition
         then ERROR_INTERNAL_ERROR
            if Random_Message'Valid = False
               or Random_Message.Tag /= GreenTLS_RNG_RESPONSE
               or Random_Message.Length /= 32
         then START_PSK_EXTENSIONS
      end START_GET_RANDOM;

      state START_PSK_EXTENSIONS is
         PSK_Key_Exchange_Modes_Extension : TLS_Handshake_CH_Extension;
         Client_Hello_Hash : Hash_Context;
      begin
         PSK_Key_Exchange_Modes_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Length, Data => Modes)
            where Modes = TLS_Handshake_PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes);
         Extensions_List := Append (Extensions_List, PSK_Key_Exchange_Modes_Extension);
         Extensions_List := Append (Extensions_List, TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_PRE_SHARED_KEY, Length => Pre_Shared_Key_CH'Length, Data => Pre_Shared_Key_CH));
         Client_Hello_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH)
            where CH = TLS_Handshake_Client_Hello'(Legacy_Version => TLS_Handshake_TLS_1_2, Random => Random_Message.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List);
         Client_Hello_Hash := Empty_Hash;
         Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash));
         Extensions_List := [for E in Extensions_List => E when E.Tag /= TLS_Handshake_EXTENSION_PRE_SHARED_KEY];
         Extensions_List := Append (Extensions_List, TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_PRE_SHARED_KEY, Length => PSK_CH'Length, Data => PSK_CH)
            where PSK_CH = TLS_Handshake_Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => Binders));
      transition
         then ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         then START_SEND
      end START_PSK_EXTENSIONS;

      state START_SEND is
      begin
         Success := Write (Record_Data_Channel, Client_Hello_Handshake_Message);
         Client_Hello_1_Hash := Empty_Hash;
         Client_Hello_1_Hash := Update_Hash (Client_Hello_1_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Transcript_Hash := Empty_Hash;
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Opaque);
         Client_Hello_Message := TLS_Handshake_Client_Hello (Client_Hello_Handshake_Message.Payload);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then START_SEND_CLIENT_EARLY_TRAFFIC_SECRET
            if Configuration.Early_Data_Enabled = True
         then WAIT_SH
      end START_SEND;

      state START_SEND_CLIENT_EARLY_TRAFFIC_SECRET is
         Client_Early_Traffic_Secret : GreenTLS_Content;
         Client_Key : GreenTLS_Content;
         Client_IV : GreenTLS_Content;
      begin
         Early_Secret := HKDF_Extract (Get_Zero_Content (Get_Hash_Length (PSKs'Head.Cipher_Suite)), GreenTLS_Content'(Data => PSKs'Head.Key));
         Client_Early_Traffic_Secret := Derive_Secret (Early_Secret.Data, "c e traffic", Get_Hash (Transcript_Hash));
         Client_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Early_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Client_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Early_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Keystore_Message := null;
         Success := Write (Record_Data_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_CLIENT, Length => KU'Length, Payload => KU)
            where KU = GreenTLS_Key_Update_Message'(Key_Length => Client_Key'Length, Key => Client_Key.Data, IV_Length => Client_IV'Length, IV => Client_IV.Data));
         Client_Early_Traffic_Secret := null;
         Client_Key := null;
         Client_IV := null;
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then WAIT_SH
      end START_SEND_CLIENT_EARLY_TRAFFIC_SECRET;

      state WAIT_SH is
      begin
         Server_Hello_Handshake_Message := Read (Record_Data_Channel);
         Transcript_Hash := Update_Hash (Transcript_Hash, Server_Hello_Handshake_Message'Opaque);
      transition
         then ERROR_DECODE_ERROR
            if Server_Hello_Handshake_Message'Valid = False
         then ERROR_UNEXPECTED_MESSAGE
            if Server_Hello_Handshake_Message.Tag /= TLS_Handshake_HANDSHAKE_SERVER_HELLO
         then ERROR_DECODE_ERROR
            if Server_Hello_Message'Valid = False
         then ERROR_PROTOCOL_VERSION
            if Server_Hello_Message.Legacy_Version /= GreenTLS_TLS_1_2
         then ERROR_ILLEGAL_PARAMETER
            if Server_Hello_Message.Legacy_Session_Id_Echo /= 0
               or Server_Hello_Message.Legacy_Compression_Method /= 0
         then ERROR_ILLEGAL_PARAMETER
            if Server_Hello_Message.Cipher_Suite not in Client_Hello_Message.Cipher_Suites
         then ERROR_MISSING_EXTENSION
            if (for all E in Server_Hello_Message.Extensions =>
                   E.Tag /= TLS_Handshake_EXTENSION_SUPPORTED_VERSIONS)
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_SUPPORTED_VERSIONS
                   and GreenTLS_TLS_1_3 not in TLS_Handshake_Supported_Versions (E.Data).Versions)
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E not in Client_Hello_Message.Extensions)
         then ERROR_ILLEGAL_PARAMETER
            if TLS_Handshake_PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE)
         then WAIT_SH_PARSE_HRR
            if Server_Hello_Message.HRR_Extensions'Present
               and Retry_Request_Received = False
         then ERROR_UNEXPECTED_MESSAGE
            if Server_Hello_Message.HRR_Extensions'Present = False
               and Retry_Request_Received = True
         then WAIT_SH_EXTENSIONS_PSK
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_PRE_SHARED_KEY)
         then WAIT_SH_EXTENSIONS_DHE
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE)
         then ERROR_INVALID_CONFIGURATION
      end WAIT_SH;

      state WAIT_SH_EXTENSIONS_PSK is
      begin
         Identity_Index := TLS_Handshake_Pre_Shared_Key_SH ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_PRE_SHARED_KEY]'Head.Data).Selected_Identity;
      transition
         then ERROR_ILLEGAL_PARAMETER
            if Identity_Index /= 0
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_EARLY_DATA)
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Client_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_PRE_SHARED_KEY
                   and TLS_Handshake_Pre_Shared_Key_CH (E.Data).Identities'Length < Identity_Index)
         then WAIT_SH_EXTENSIONS_PSK_REQUEST
      end WAIT_SH_EXTENSIONS_PSK;

      state WAIT_SH_EXTENSIONS_PSK_REQUEST is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_PSKS, Length => Selected_Identity'Length, Payload => Selected_Identity)
            where Selected_Identity = FIXME);
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS_KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS_KEYSTORE_REQUEST_PSK
               or GreenTLS_PSK (Keystore_Message.Payload)'Valid = False
         then WAIT_SH_EXTENSIONS_PSK_VALIDATION
      end WAIT_SH_EXTENSIONS_PSK_REQUEST;

      state WAIT_SH_EXTENSIONS_PSK_VALIDATION is
         Identity_Cipher_Suite : TLS_Handshake_Cipher_Suite;
      begin
         Identity_Cipher_Suite := GreenTLS_PSK (Keystore_Message.Payload).Cipher_Suite;
      transition
         then ERROR_ILLEGAL_PARAMETER
            if Identity_Cipher_Suite /= Server_Hello_Message.Cipher_Suite
         then WAIT_SH_EXTENSIONS_DHE
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE)
         then SET_RECORD_KEYS
      end WAIT_SH_EXTENSIONS_PSK_VALIDATION;

      state WAIT_SH_EXTENSIONS_DHE is
      begin
         Selected_Group := TLS_Handshake_Key_Share_SH ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE]'Head.Data).Group;
         DHE_Accepted := True;
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for some S in TLS_Handshake_Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE]'Head.Data).Shares =>
                   S.Group = Selected_Group) = False
         then SET_RECORD_KEYS
      end WAIT_SH_EXTENSIONS_DHE;

      state WAIT_SH_PARSE_HRR is
         Client_Supported_Groups : TLS_Handshake_Named_Groups;
      begin
         Retry_Request_Received := True;
         Client_Supported_Groups := TLS_Handshake_Supported_Groups ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SUPPORTED_GROUPS]'Head.Data).Groups;
         Client_Shares := TLS_Handshake_Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE]'Head.Data).Shares;
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E not in Client_Hello_Message.Extensions
                   and E.Tag /= TLS_Handshake_EXTENSION_COOKIE)
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE
                   and TLS_Handshake_Key_Share_HRR (E.Data).Selected_Group not in Client_Supported_Groups)
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Server_Hello_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE
                   and (for some S in Client_Shares =>
                           S.Group = TLS_Handshake_Key_Share_HRR (E.Data).Selected_Group))
         then WAIT_SH_PREPARE_CH
      end WAIT_SH_PARSE_HRR;

      state WAIT_SH_PREPARE_CH is
      begin
         Extensions_List'Reset;
         Extensions_List := Extend (Extensions_List, [for E in Client_Hello_Message.Extensions => E when E.Tag /= TLS_Handshake_EXTENSION_KEY_SHARE
         and E.Tag /= TLS_Handshake_EXTENSION_EARLY_DATA
         and E.Tag /= TLS_Handshake_EXTENSION_PRE_SHARED_KEY]);
      transition
         then WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PREPARE_CH;

      state WAIT_SH_PREPARE_CH_DISPATCH is
      begin
      transition
         then WAIT_SH_PREPARE_CH_KEY_SHARE
            if CH_Key_Share_Prepared = False
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE)
         then WAIT_SH_PREPARE_CH_COOKIE
            if CH_Cookie_Prepared = False
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_COOKIE)
         then WAIT_SH_PREPARE_CH_PSK
            if CH_PSK_Prepared = False
               and (for some E in Server_Hello_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_PRE_SHARED_KEY)
         then WAIT_SH_SEND_CH
      end WAIT_SH_PREPARE_CH_DISPATCH;

      state WAIT_SH_PREPARE_CH_KEY_SHARE is
      begin
         Extensions_List := Append (Extensions_List, TLS_Handshake_Extension'(Tag => TLS_Handshake_EXTENSION_KEY_SHARE, Data_Length => Key_Share'Length, Data => Key_Share)
            where Key_Share = TLS_Handshake_Key_Share_CH'(Length => Entries'Length, Shares => Entries)
                     where Entries = [for E in Client_Shares => E when E.Group = Selected_Group]);
         CH_Key_Share_Prepared := True;
      transition
         then WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PREPARE_CH_KEY_SHARE;

      state WAIT_SH_PREPARE_CH_COOKIE is
      begin
         Extensions_List := Append (Extensions_List, [for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_COOKIE]'Head);
         CH_Cookie_Prepared := True;
      transition
         then WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PREPARE_CH_COOKIE;

      state WAIT_SH_PREPARE_CH_PSK is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_PSKS, Length => Connection'Length, Payload => Connection));
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or Keystore_Message.Tag /= GreenTLS_KEYSTORE_RESPONSE
               or Keystore_Message.Request /= GreenTLS_KEYSTORE_REQUEST_PSKS
               or (Keystore_Message.Length = 0
                   and TLS_Handshake_PSK_DHE_KE not in Configuration.PSK_Key_Exchange_Modes)
               or GreenTLS_PSK_Message (Keystore_Message.Payload)'Valid = False
         then WAIT_SH_NO_PSK_EXTENSION
            if Keystore_Message.Length = 0
         then WAIT_SH_PSK_EXTENSION_CHECK
      end WAIT_SH_PREPARE_CH_PSK;

      state WAIT_SH_PSK_EXTENSION_CHECK is
      begin
         PSKs := [for K in GreenTLS_PSK_Message (Keystore_Message.Payload).PSKs => K when K.Cipher_Suite = Server_Hello_Message.Cipher_Suite];
         Binders_Length := Calculate_Binders_Length (PSKs);
         PSK_Identities := [for K in PSKs => K.Identity when True];
         Pre_Shared_Key_CH := TLS_Handshake_Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => FIXME_NULL);
      transition
         then ERROR_INTERNAL_ERROR
            if Pre_Shared_Key_CH'Valid = False
         then WAIT_SH_PSK_EXTENSIONS
      end WAIT_SH_PSK_EXTENSION_CHECK;

      state WAIT_SH_PSK_EXTENSIONS is
         PSK_Key_Exchange_Modes_Extension : TLS_Handshake_CH_Extension;
         Client_Hello_Hash : Hash_Context;
      begin
         PSK_Key_Exchange_Modes_Extension := TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_PSK_KEY_EXCHANGE_MODES, Data_Length => Modes'Length, Data => Modes)
            where Modes = TLS_Handshake_PSK_Key_Exchange_Modes'(Length => Configuration.PSK_Key_Exchange_Modes_Length, Modes => Configuration.PSK_Key_Exchange_Modes);
         Extensions_List := Append (Extensions_List, PSK_Key_Exchange_Modes_Extension);
         Extensions_List := Append (Extensions_List, TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_PRE_SHARED_KEY, Length => Pre_Shared_Key_CH'Length, Data => Pre_Shared_Key_CH));
         Client_Hello_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH)
            where CH = TLS_Handshake_Client_Hello'(Legacy_Version => TLS_Handshake_TLS_1_2, Random => Random_Message.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List);
         Client_Hello_Hash := Empty_Hash;
         Client_Hello_Hash := Update_Hash (Client_Hello_Hash, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Binders := Calculate_Binders (PSKs, Get_Hash (Client_Hello_Hash));
         Extensions_List := [for E in Extensions_List => E when E.Tag /= TLS_Handshake_EXTENSION_PRE_SHARED_KEY];
         Extensions_List := Append (Extensions_List, TLS_Handshake_CH_Extension'(Tag => TLS_Handshake_EXTENSION_PRE_SHARED_KEY, Length => PSK_CH'Length, Data => PSK_CH)
            where PSK_CH = TLS_Handshake_Pre_Shared_Key_CH'(Identities_Length => PSK_Identities'Length, Identities => PSK_Identities, Binders_Length => Binders_Length, Binders => Binders));
         CH_PSK_Prepared := True;
      transition
         then ERROR_INTERNAL_ERROR
            if Extensions_List'Valid = False
         then WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_PSK_EXTENSIONS;

      state WAIT_SH_NO_PSK_EXTENSION is
      begin
         CH_PSK_Prepared := True;
      transition
         then WAIT_SH_PREPARE_CH_DISPATCH
      end WAIT_SH_NO_PSK_EXTENSION;

      state WAIT_SH_SEND_CH is
         Random : GreenTLS_Content;
         Transcript_Hash_2 : GreenTLS_Content;
      begin
         Transcript_Hash_2 := Empty_Hash;
         Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_MESSAGE_HASH, Length => CH1_Hash'Length, Payload => CH1_Hash.Data)'Opaque)
            where CH1_Hash = Get_Hash (Client_Hello_1_Hash);
         Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Server_Hello_Handshake_Message'Opaque);
         Transcript_Hash_2 := Update_Hash (Transcript_Hash_2, Truncate_Client_Hello (Client_Hello_Handshake_Message)'Opaque);
         Random := Client_Hello_Message.Random;
         Client_Hello_Handshake_Message'Reset;
         Client_Hello_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CLIENT_HELLO, Length => CH'Length, Payload => CH)
            where CH = TLS_Handshake_Client_Hello'(Legacy_Version => TLS_Handshake_TLS_1_2, Random => Random.Data, Legacy_Session_ID_Length => 0, Cipher_Suites_Length => Configuration.Cipher_Suites'Length, Cipher_Suites => Configuration.Cipher_Suites, Legacy_Compression_Methods_Length => 0, Extensions_Length => Extensions_List'Length, Extensions => Extensions_List);
         Success := Write (Record_Data_Channel, Client_Hello_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Hello_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then WAIT_SH
      end WAIT_SH_SEND_CH;

      state SET_RECORD_KEYS is
         Derived_Early_Secret : GreenTLS_Content;
         Handshake_Secret : GreenTLS_Content;
         Server_Key : GreenTLS_Content;
         Server_IV : GreenTLS_Content;
         Client_Key : GreenTLS_Content;
         Client_IV : GreenTLS_Content;
         Success_Client : Boolean;
         Success_Server : Boolean;
      begin
         Derived_Early_Secret := Derive_Secret (Early_Secret, "derived", Get_Hash (Empty_Hash));
         Early_Secret := null;
         Handshake_Secret := HKDF_Extract (Derived_Early_Secret, Key)
            where Key = Calculate_ECDHE_Key (Client_Share, TLS_Handshake_Key_Share_Entry ([for E in Server_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE]'Head).Data)
                     where Client_Share = [for S in TLS_Handshake_Key_Share_CH ([for E in Client_Hello_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE]'Head.Data).Shares => S when S.Group = Selected_Group]'Head;
         Derived_Early_Secret := null;
         Client_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "c hs traffic", Get_Hash (Transcript_Hash));
         Server_Handshake_Traffic_Secret := Derive_Secret (Handshake_Secret, "s hs traffic", Get_Hash (Transcript_Hash));
         Server_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Handshake_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Server_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Handshake_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Client_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Handshake_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Client_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Handshake_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Success_Client := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_CLIENT, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Record_Keys'(Key_Length => Client_Key'Length, Key => Client_Key.Data, IV_Length => Client_IV'Length, IV => Client_IV.Data));
         Success_Server := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_SERVER, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Record_Keys'(Key_Length => Server_Key'Length, Key => Server_Key.Data, IV_Length => Server_IV'Length, IV => Server_IV.Data));
         Server_Handshake_Traffic_Secret := null;
         Server_Key := null;
         Server_IV := null;
         Client_Key := null;
         Client_IV := null;
         Derived_Handshake_Secret := Derive_Secret (Handshake_Secret, "derived", Get_Hash (Empty_Hash));
         Handshake_Secret := null;
      transition
         then ERROR_INTERNAL_ERROR
            if Success_Client = False
               or Success_Server = False
         then WAIT_EE
      end SET_RECORD_KEYS;

      state WAIT_EE is
      begin
         Encrypted_Extensions_Handshake_Message := Read (Record_Data_Channel);
      transition
         then ERROR_DECODE_ERROR
            if Encrypted_Extensions_Handshake_Message'Valid = False
         then ERROR_UNEXPECTED_MESSAGE
            if Encrypted_Extensions_Handshake_Message.Tag /= TLS_Handshake_HANDSHAKE_ENCRYPTED_EXTENSIONS
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE;

      state WAIT_EE_PARSE_EXTENSIONS is
      begin
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for some E in Encrypted_Extensions_Message.Extensions =>
                   E.Tag = TLS_Handshake_EXTENSION_STATUS_REQUEST
                   or E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS
                   or E.Tag = TLS_Handshake_EXTENSION_SIGNED_CERTIFICATE_TIMESTAMP
                   or E.Tag = TLS_Handshake_EXTENSION_PADDING
                   or E.Tag = TLS_Handshake_EXTENSION_KEY_SHARE
                   or E.Tag = TLS_Handshake_EXTENSION_PRE_SHARED_KEY
                   or E.Tag = TLS_Handshake_EXTENSION_PSK_KEY_EXCHANGE_MODES
                   or E.Tag = TLS_Handshake_EXTENSION_COOKIE
                   or E.Tag = TLS_Handshake_EXTENSION_SUPPORTED_VERSIONS
                   or E.Tag = TLS_Handshake_EXTENSION_CERTIFICATE_AUTHORITIES
                   or E.Tag = TLS_Handshake_EXTENSION_OID_FILTERS
                   or E.Tag = TLS_Handshake_EXTENSION_POST_HANDSHAKE_AUTH
                   or E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT)
         then ERROR_ILLEGAL_PARAMETER
            if Server_Name_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SERVER_NAME)
               and Configuration.Server_Name_Enabled = False
         then WAIT_EE_PROCESS_SERVER_NAME
            if Server_Name_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SERVER_NAME)
         then WAIT_EE_PROCESS_MAX_FRAGMENT_LENGTH
            if Max_Fragment_Length_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_MAX_FRAGMENT_LENGTH)
         then WAIT_EE_PROCESS_SUPPORTED_GROUPS
            if Supported_Groups_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SUPPORTED_GROUPS)
         then WAIT_EE_PROCESS_HEARTBEAT
            if Heartbeat_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_HEARTBEAT)
         then WAIT_EE_PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION
            if Application_Layer_Protocol_Negotiation_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION)
         then WAIT_EE_PROCESS_EARLY_DATA
            if Early_Data_Received = False
               and (for some E in Encrypted_Extensions_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_EARLY_DATA)
         then WAIT_EE_CHECK_EXTENSIONS
      end WAIT_EE_PARSE_EXTENSIONS;

      state WAIT_EE_PROCESS_SERVER_NAME is
      begin
         Server_Name_Extension := [for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SERVER_NAME]'Head;
         Server_Name_Received := True;
      transition
         then ERROR_ILLEGAL_PARAMETER
            if Server_Name_Extension.Data_Length > 0
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_SERVER_NAME;

      state WAIT_EE_PROCESS_MAX_FRAGMENT_LENGTH is
      begin
         Max_Fragment_Length := TLS_Handshake_Max_Fragment_Length ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_MAX_FRAGMENT_LENGTH]'Head.Data).Max_Fragment_Length;
         Max_Fragment_Length_Received := True;
      transition
         then ERROR_ILLEGAL_PARAMETER
            if Configuration.Max_Fragment_Length /= Max_Fragment_Length
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_MAX_FRAGMENT_LENGTH;

      state WAIT_EE_PROCESS_SUPPORTED_GROUPS is
      begin
         Server_Preferred_Groups := TLS_Handshake_Supported_Groups ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SUPPORTED_GROUPS]'Head.Data).Groups;
         Supported_Groups_Received := True;
      transition
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_SUPPORTED_GROUPS;

      state WAIT_EE_PROCESS_HEARTBEAT is
         Server_Heartbeat_Mode : TLS_Handshake_Heartbeat_Mode;
      begin
         Server_Heartbeat_Mode := TLS_Handshake_Heartbeat ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_HEARTBEAT]'Head.Data).Mode;
         Success := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_HEARTBEAT_MODE, Length => Data'Length, Payload => Data)
            where Data = GreenTLS_Heartbeat_Control_Message'(Local => Configuration.Heartbeat_Mode, Remote => Server_Heartbeat_Mode));
         Heartbeat_Received := True;
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_HEARTBEAT;

      state WAIT_EE_PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION is
         Protocols : TLS_Handshake_Protocol_Names;
      begin
         Protocols := TLS_Handshake_Protocol_Name_List ([for E in Encrypted_Extensions_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_APPLICATION_LAYER_PROTOCOL_NEGOTIATION]'Head.Data).Protocol_Name_List;
         Success := Write (Application_Control_Channel, GreenTLS_Application_Control_Message'(Tag => GreenTLS_APPLICATION_PROTOCOL, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Application_Protocol_Message'(Protocol => Protocols'Head));
         Application_Layer_Protocol_Negotiation_Received := True;
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then ERROR_ILLEGAL_PARAMETER
            if Protocols'Length /= 1
         then ERROR_ILLEGAL_PARAMETER
            if (for all P in Configuration.Protocols =>
                   P /= Protocols'Head)
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_APPLICATION_LAYER_PROTOCOL_NEGOTIATION;

      state WAIT_EE_PROCESS_EARLY_DATA is
      begin
         Early_Data_Received := True;
      transition
         then WAIT_EE_PARSE_EXTENSIONS
      end WAIT_EE_PROCESS_EARLY_DATA;

      state WAIT_EE_CHECK_EXTENSIONS is
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, Encrypted_Extensions_Handshake_Message'Opaque);
      transition
         then ERROR_MISSING_EXTENSION
            if Configuration.Server_Name_Enabled = True
               and Server_Name_Received = False
         then ERROR_MISSING_EXTENSION
            if Configuration.Max_Fragment_Length_Enabled = True
               and Max_Fragment_Length_Received = False
         then WAIT_EE_NO_EARLY_DATA
            if Configuration.Early_Data_Enabled = True
               and Early_Data_Received = False
         then WAIT_EE_DISPATCH
      end WAIT_EE_CHECK_EXTENSIONS;

      state WAIT_EE_NO_EARLY_DATA is
      begin
         Success := Write (Application_Control_Channel, GreenTLS_Application_Control_Message'(Tag => GreenTLS_APPLICATION_NO_EARLY_DATA, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Application_No_Early_Data_Message'(null message));
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then WAIT_EE_DISPATCH
      end WAIT_EE_NO_EARLY_DATA;

      state WAIT_EE_DISPATCH is
      begin
      transition
         then WAIT_CERT_CR
            if DHE_Accepted = True
         then WAIT_FINISHED
      end WAIT_EE_DISPATCH;

      state WAIT_CERT_CR is
      begin
         CCR_Handshake_Message := Read (Record_Data_Channel);
         Certificate_Authorities := TLS_Handshake_Certificate_Authorities'(Length => 0);
         OID_Filters := TLS_Handshake_OID_Filters'(Length => 0);
         Signature_Algorithms := TLS_Handshake_Signature_Algorithms'(Length => 0);
         Signature_Algorithms_Cert := TLS_Handshake_Signature_Algorithms_Cert'(Length => 0);
      transition
         then ERROR_DECODE_ERROR
            if CCR_Handshake_Message'Valid = False
         then ERROR_UNEXPECTED_MESSAGE
            if CCR_Handshake_Message.Tag /= TLS_Handshake_HANDSHAKE_CERTIFICATE
               and CCR_Handshake_Message.Tag /= TLS_Handshake_HANDSHAKE_CERTIFICATE_REQUEST
         then PARSE_CERT
            if Certificate_Message'Valid = True
         then PARSE_CR
            if Certificate_Request_Message'Valid = True
         then ERROR_DECODE_ERROR
      end WAIT_CERT_CR;

      state PARSE_CR is
      begin
         Certificate_Request := TLS_Handshake_Certificate_Request'(Certificate_Request_Context_Length => Certificate_Request_Message.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request_Message.Certificate_Request_Context, Extensions_Length => Certificate_Request_Message.Extensions_Length, Extensions => Certificate_Request_Message.Extensions);
      transition
         then PARSE_CR_EXTENSIONS
      end PARSE_CR;

      state PARSE_CR_EXTENSIONS is
      begin
         Certificate_Request_Received := True;
      transition
         then PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES
            if Certificate_Authorities_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_CERTIFICATE_AUTHORITIES)
         then PARSE_CR_PARSE_OID_FILTERS
            if OID_Filters_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_OID_FILTERS)
         then PARSE_CR_PARSE_SIGNATURE_ALGORITHMS
            if Signature_Algorithms_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS)
         then PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT
            if Signature_Algorithms_Cert_Received = False
               and (for some E in Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT)
         then PARSE_CR_CHECK_EXTENSIONS
      end PARSE_CR_EXTENSIONS;

      state PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES is
      begin
         Certificate_Authorities_Received := True;
         Certificate_Authorities := TLS_Handshake_Certificate_Authorities ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_CERTIFICATE_AUTHORITIES]'Head.Data);
      transition
         then PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES;

      state PARSE_CR_PARSE_OID_FILTERS is
      begin
         OID_Filters_Received := True;
         OID_Filters := TLS_Handshake_OID_Filters ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_OID_FILTERS]'Head.Data);
      transition
         then PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_OID_FILTERS;

      state PARSE_CR_PARSE_SIGNATURE_ALGORITHMS is
      begin
         Signature_Algorithms_Received := True;
         Signature_Algorithms := TLS_Handshake_Signature_Algorithms ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS]'Head.Data);
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms =>
                   A not in Signature_Algorithms)
         then PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_SIGNATURE_ALGORITHMS;

      state PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT is
      begin
         Signature_Algorithms_Cert_Received := True;
         Signature_Algorithms_Cert := TLS_Handshake_Signature_Algorithms_Cert ([for E in Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT]'Head.Data);
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms_Cert =>
                   A not in Signature_Algorithms_Cert)
         then PARSE_CR_EXTENSIONS
      end PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT;

      state PARSE_CR_CHECK_EXTENSIONS is
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque);
      transition
         then ERROR_MISSING_EXTENSION
            if Signature_Algorithms_Received = False
         then WAIT_CERT
      end PARSE_CR_CHECK_EXTENSIONS;

      state WAIT_CERT is
      begin
         CCR_Handshake_Message := Read (Record_Data_Channel);
      transition
         then ERROR_DECODE_ERROR
            if CCR_Handshake_Message'Valid = False
               or Certificate_Message'Valid = False
         then ERROR_UNEXPECTED_MESSAGE
            if CCR_Handshake_Message.Tag /= TLS_Handshake_HANDSHAKE_CERTIFICATE
         then ERROR_ILLEGAL_PARAMETER
            if Certificate_Message.Certificate_Request_Context_Length /= 0
         then ERROR_ILLEGAL_PARAMETER
            if Certificate_Message.Certificate_List_Length = 0
         then PARSE_CERT
      end WAIT_CERT;

      state PARSE_CERT is
         Validation_Result : GreenTLS_Certificate_Validation_Result;
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque);
         Validation_Result := Validate_Server_Certificate (Certificate_Message, Configuration, Connection);
      transition
         then WAIT_CV
            if Validation_Result = GreenTLS_VALID_CERTIFICATE
         then ERROR_BAD_CERTIFICATE
            if Validation_Result = GreenTLS_BAD_CERTIFICATE
         then ERROR_UNSUPPORTED_CERTIFICATE
            if Validation_Result = GreenTLS_UNSUPPORTED_CERTIFICATE
         then ERROR_CERTIFICATE_REVOKED
            if Validation_Result = GreenTLS_CERTIFICATE_REVOKED
         then ERROR_CERTIFICATE_EXPIRED
            if Validation_Result = GreenTLS_CERTIFICATE_EXPIRED
         then ERROR_CERTIFICATE_UNKNOWN
            if Validation_Result = GreenTLS_CERTIFICATE_UNKNOWN
         then ERROR_INTERNAL_ERROR
      end PARSE_CERT;

      state WAIT_CV is
      begin
         Certificate_Verify_Handshake_Message := Read (Record_Data_Channel);
         Transcript_Hash := Update_Hash (Transcript_Hash, Certificate_Verify_Handshake_Message'Opaque);
      transition
         then ERROR_DECODE_ERROR
            if Certificate_Verify_Handshake_Message'Valid = False
               or Certificate_Verify_Message'Valid = False
         then ERROR_ILLEGAL_PARAMETER
            if Certificate_Verify_Message.Algorithm not in Configuration.Signature_Algorithms
         then WAIT_CV_VALIDATE
      end WAIT_CV;

      state WAIT_CV_VALIDATE is
         Validation_Result : GreenTLS_Signature_Validation_Result;
      begin
         Validation_Result := Validate_Certificate_Verify_Signature (Certificate_Message, Certificate_Verify_Message, Get_Hash (Transcript_Hash));
      transition
         then ERROR_ILLEGAL_PARAMETER
            if Validation_Result = GreenTLS_ILLEGAL_PARAMETER
         then ERROR_DECRYPT_ERROR
            if Validation_Result = GreenTLS_DECRYPT_ERROR
         then WAIT_FINISHED
            if Validation_Result = GreenTLS_VALID_SIGNATURE
         then ERROR_INTERNAL_ERROR
      end WAIT_CV_VALIDATE;

      state WAIT_FINISHED is
         Verify_Data : GreenTLS_Content;
         Master_Secret : GreenTLS_Content;
      begin
         Hash_Length := Get_Hash_Length (Server_Hello_Message.Cipher_Suite);
         Finished_Handshake_Message := Read (Record_Data_Channel);
         Finished_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Handshake_Traffic_Secret), "finished", Get_Hash (Empty_Hash), Hash_Length);
         Client_Handshake_Traffic_Secret := null;
         Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash));
         Transcript_Hash := Update_Hash (Transcript_Hash, Finished_Handshake_Message'Opaque);
         Master_Secret := HKDF_Extract (Derived_Handshake_Secret, Get_Zero_Content (Hash_Length));
         Derived_Handshake_Secret := null;
         Client_Application_Traffic_Secret := Derive_Secret (Master_Secret, "c ap traffic", Get_Hash (Transcript_Hash));
         Server_Application_Traffic_Secret := Derive_Secret (Master_Secret, "s ap traffic", Get_Hash (Transcript_Hash));
         Resumption_Master_Secret := Derive_Secret (Master_Secret, "res master", Get_Hash (Transcript_Hash));
         Master_Secret := null;
      transition
         then ERROR_DECRYPT_ERROR
            if Finished_Handshake_Message'Valid = False
               or Finished_Message'Valid = False
               or Finished_Message.Verify_Data /= Verify_Data
         then SEND_END_OF_EARLY_DATA
            if Early_Data_Received = True
         then CHECK_CERTIFICATE_REQUEST
      end WAIT_FINISHED;

      state SEND_END_OF_EARLY_DATA is
      begin
         Success := Write (Record_Data_Channel, TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_END_OF_EARLY_DATA, Length => 0));
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then CHECK_CERTIFICATE_REQUEST
      end SEND_END_OF_EARLY_DATA;

      state CHECK_CERTIFICATE_REQUEST is
      begin
      transition
         then SEND_FINISHED
            if Certificate_Request_Received = False
         then QUERY_CERTIFICATES
      end CHECK_CERTIFICATE_REQUEST;

      state QUERY_CERTIFICATES is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_CERTIFICATES, Length => Query'Length, Payload => Query)
            where Query = GreenTLS_Certificate_Query'(Certificate_Authorities => Certificate_Authorities, OID_Filters => OID_Filters, Signature_Algorithms => Signature_Algorithms, Signature_Algorithms_Cert => Signature_Algorithms_Cert));
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or GreenTLS_Certificate (Keystore_Message.Payload)'Valid = False
         then SEND_CERTIFICATE
            if GreenTLS_Certificate (Keystore_Message.Payload).Length > 0
         then SEND_EMPTY_CERTIFICATE
      end QUERY_CERTIFICATES;

      state SEND_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake_Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CERTIFICATE, Length => Certificate'Length, Payload => Certificate)
            where Certificate = TLS_Handshake_Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => C.Length, Certificate_List => C.Certificate_List)
                     where C = GreenTLS_Certificate (Keystore_Message.Payload);
         Success := Write (Record_Data_Channel, Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then QUERY_SIGNATURE
      end SEND_CERTIFICATE;

      state SEND_EMPTY_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake_Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CERTIFICATE, Length => Certificate'Length, Payload => Certificate)
            where Certificate = TLS_Handshake_Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => 0);
         Success := Write (Record_Data_Channel, Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then SEND_FINISHED
      end SEND_EMPTY_CERTIFICATE;

      state QUERY_SIGNATURE is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_SIGNATURE, Length => Query'Length, Payload => Query)
            where Query = GreenTLS_Signature_Query'(ID => GreenTLS_Certificate (Keystore_Message.Payload).ID, Length => Hash'Length, Data => Hash)
                     where Hash = Get_Hash (Transcript_Hash).Data);
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or TLS_Handshake_Certificate_Verify (Keystore_Message.Payload)'Valid = False
         then SEND_CERTIFICATE_VERIFY
      end QUERY_SIGNATURE;

      state SEND_CERTIFICATE_VERIFY is
         Client_Certificate_Verify_Handshake_Message : TLS_Handshake_Handshake;
      begin
         Client_Certificate_Verify_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CERTIFICATE_VERIFY, Length => Certificate_Verify'Length, Payload => Certificate_Verify)
            where Certificate_Verify = TLS_Handshake_Certificate_Verify (Keystore_Message.Payload);
         Success := Write (Record_Data_Channel, Client_Certificate_Verify_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Verify_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then SEND_FINISHED
      end SEND_CERTIFICATE_VERIFY;

      state SEND_FINISHED is
         Verify_Data : GreenTLS_Content;
      begin
         Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash));
         Finished_Key := null;
         Finished_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_FINISHED, Length => Finished'Length, Payload => Finished)
            where Finished = TLS_Handshake_Finished'(Verify_Data => Verify_Data);
         Success := Write (Record_Data_Channel, Finished_Handshake_Message);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then SEND_APPLICATION_RECORD_KEYS
      end SEND_FINISHED;

      state SEND_APPLICATION_RECORD_KEYS is
         Server_Key : GreenTLS_Content;
         Server_IV : GreenTLS_Content;
         Client_Key : GreenTLS_Content;
         Client_IV : GreenTLS_Content;
         Success_Client : Boolean;
         Success_Server : Boolean;
      begin
         Server_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Server_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Client_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Client_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Success_Client := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_CLIENT, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Record_Keys'(Key_Length => Client_Key'Length, Key => Client_Key.Data, IV_Length => Client_IV'Length, IV => Client_IV.Data));
         Success_Server := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_SERVER, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Record_Keys'(Key_Length => Server_Key'Length, Key => Server_Key.Data, IV_Length => Server_IV'Length, IV => Server_IV.Data));
         Server_Application_Traffic_Secret := null;
      transition
         then ERROR_INTERNAL_ERROR
            if Success_Client = False
               or Success_Server = False
         then CONNECTED
      end SEND_APPLICATION_RECORD_KEYS;

      state CONNECTED is
      begin
         Post_Handshake_Handshake_Message := Read (Record_Data_Channel);
      transition
         then ERROR_DECODE_ERROR
            if Post_Handshake_Handshake_Message'Valid = False
               or (Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_NEW_SESSION_TICKET
                   and New_Session_Ticket_Message'Valid = False)
               or (Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_CERTIFICATE_REQUEST
                   and PHA_Certificate_Request_Message'Valid = False)
               or (Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_KEY_UPDATE
                   and Key_Update_Message'Valid = False)
         then CONNECTED_NEW_SESSION_TICKET
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_NEW_SESSION_TICKET
               and New_Session_Ticket_Message'Valid = True
         then CONNECTED_POST_HANDSHAKE_AUTH
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_CERTIFICATE_REQUEST
               and Configuration.Post_Handshake_Auth_Enabled = True
         then ERROR_UNEXPECTED_MESSAGE
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_CERTIFICATE_REQUEST
               and Configuration.Post_Handshake_Auth_Enabled = False
         then CONNECTED_KEY_UPDATE
            if Post_Handshake_Handshake_Message.Tag = TLS_Handshake_HANDSHAKE_KEY_UPDATE
         then ERROR_UNEXPECTED_MESSAGE
      end CONNECTED;

      state CONNECTED_NEW_SESSION_TICKET is
         PSK : GreenTLS_Content;
      begin
         PSK := HKDF_Expand_Label (GreenTLS_Content'(Data => Resumption_Master_Secret.Data), "resumption", GreenTLS_Content'(Data => New_Session_Ticket_Message.Ticket_Nonce), Hash_Length);
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_NEW_SESSION_TICKET, Length => NST'Length, Payload => NST)
            where NST = GreenTLS_New_Session_Ticket'(Connection => Connection, Session => New_Session_Ticket_Message, PSK_Length => PSK'Length, PSK => PSK));
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
         then CONNECTED
      end CONNECTED_NEW_SESSION_TICKET;

      state CONNECTED_POST_HANDSHAKE_AUTH is
      begin
         Certificate_Authorities_Received := False;
         OID_Filters_Received := False;
         Signature_Algorithms_Received := False;
         Signature_Algorithms_Cert_Received := False;
      transition
         then CONNECTED_PHA_PARSE_CR
      end CONNECTED_POST_HANDSHAKE_AUTH;

      state CONNECTED_PHA_PARSE_CR is
      begin
         Certificate_Request := TLS_Handshake_Certificate_Request'(Certificate_Request_Context_Length => PHA_Certificate_Request_Message.Certificate_Request_Context_Length, Certificate_Request_Context => PHA_Certificate_Request_Message.Certificate_Request_Context, Extensions_Length => PHA_Certificate_Request_Message.Extensions_Length, Extensions => PHA_Certificate_Request_Message.Extensions);
      transition
         then CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR;

      state CONNECTED_PHA_PARSE_CR_EXTENSIONS is
      begin
      transition
         then CONNECTED_PHA_PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES
            if Certificate_Authorities_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_CERTIFICATE_AUTHORITIES)
         then CONNECTED_PHA_PARSE_CR_PARSE_OID_FILTERS
            if OID_Filters_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_OID_FILTERS)
         then CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS
            if Signature_Algorithms_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS)
         then CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT
            if Signature_Algorithms_Cert_Received = False
               and (for some E in PHA_Certificate_Request_Message.Extensions =>
                       E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT)
         then CONNECTED_PHA_PARSE_CR_CHECK_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_EXTENSIONS;

      state CONNECTED_PHA_PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES is
      begin
         Certificate_Authorities_Received := True;
         Certificate_Authorities := TLS_Handshake_Certificate_Authorities ([for E in PHA_Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_CERTIFICATE_AUTHORITIES]'Head.Data);
      transition
         then CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_CERTIFICATE_AUTHORITIES;

      state CONNECTED_PHA_PARSE_CR_PARSE_OID_FILTERS is
      begin
         OID_Filters_Received := True;
         OID_Filters := TLS_Handshake_OID_Filters ([for E in PHA_Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_OID_FILTERS]'Head.Data);
      transition
         then CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_OID_FILTERS;

      state CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS is
      begin
         Signature_Algorithms_Received := True;
         Signature_Algorithms := TLS_Handshake_Signature_Algorithms ([for E in PHA_Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS]'Head.Data);
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms =>
                   A not in Signature_Algorithms)
         then CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS;

      state CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT is
      begin
         Signature_Algorithms_Cert_Received := True;
         Signature_Algorithms_Cert := TLS_Handshake_Signature_Algorithms_Cert ([for E in PHA_Certificate_Request_Message.Extensions => E when E.Tag = TLS_Handshake_EXTENSION_SIGNATURE_ALGORITHMS_CERT]'Head.Data);
      transition
         then ERROR_ILLEGAL_PARAMETER
            if (for all A in Configuration.Signature_Algorithms_Cert =>
                   A not in Signature_Algorithms_Cert)
         then CONNECTED_PHA_PARSE_CR_EXTENSIONS
      end CONNECTED_PHA_PARSE_CR_PARSE_SIGNATURE_ALGORITHMS_CERT;

      state CONNECTED_PHA_PARSE_CR_CHECK_EXTENSIONS is
      begin
         Transcript_Hash := Update_Hash (Transcript_Hash, CCR_Handshake_Message'Opaque);
      transition
         then ERROR_MISSING_EXTENSION
            if Signature_Algorithms_Received = False
         then CONNECTED_PHA_QUERY_CERTIFICATES
      end CONNECTED_PHA_PARSE_CR_CHECK_EXTENSIONS;

      state CONNECTED_PHA_QUERY_CERTIFICATES is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_CERTIFICATES, Length => Query'Length, Payload => Query)
            where Query = GreenTLS_Certificate_Query'(Certificate_Authorities => Certificate_Authorities, OID_Filters => OID_Filters, Signature_Algorithms => Signature_Algorithms, Signature_Algorithms_Cert => Signature_Algorithms_Cert));
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or GreenTLS_Certificate (Keystore_Message.Payload)'Valid = False
         then CONNECTED_PHA_SEND_CERTIFICATE
            if GreenTLS_Certificate (Keystore_Message.Payload).Length > 0
         then CONNECTED_PHA_SEND_EMPTY_CERTIFICATE
      end CONNECTED_PHA_QUERY_CERTIFICATES;

      state CONNECTED_PHA_SEND_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake_Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CERTIFICATE, Length => Certificate'Length, Payload => Certificate)
            where Certificate = TLS_Handshake_Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => C.Length, Certificate_List => C.Certificate_List)
                     where C = GreenTLS_Certificate (Keystore_Message.Payload);
         Success := Write (Record_Data_Channel, Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then CONNECTED_PHA_QUERY_SIGNATURE
      end CONNECTED_PHA_SEND_CERTIFICATE;

      state CONNECTED_PHA_SEND_EMPTY_CERTIFICATE is
         Client_Certificate_Handshake_Message : TLS_Handshake_Handshake;
      begin
         Client_Certificate_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CERTIFICATE, Length => Certificate'Length, Payload => Certificate)
            where Certificate = TLS_Handshake_Certificate'(Certificate_Request_Context_Length => Certificate_Request.Certificate_Request_Context_Length, Certificate_Request_Context => Certificate_Request.Certificate_Request_Context, Certificate_List_Length => 0);
         Success := Write (Record_Data_Channel, Client_Certificate_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then CONNECTED_PHA_SEND_FINISHED
      end CONNECTED_PHA_SEND_EMPTY_CERTIFICATE;

      state CONNECTED_PHA_QUERY_SIGNATURE is
      begin
         Keystore_Message := Call (Keystore_Channel, GreenTLS_Keystore_Message'(Tag => GreenTLS_KEYSTORE_REQUEST, Request => GreenTLS_KEYSTORE_REQUEST_SIGNATURE, Length => Query'Length, Payload => Query)
            where Query = GreenTLS_Signature_Query'(ID => GreenTLS_Certificate (Keystore_Message.Payload).ID, Length => Hash'Length, Data => Hash)
                     where Hash = Get_Hash (Transcript_Hash).Data);
      transition
         then ERROR_INTERNAL_ERROR
            if Keystore_Message'Valid = False
               or TLS_Handshake_Certificate_Verify (Keystore_Message.Payload)'Valid = False
         then CONNECTED_PHA_SEND_CERTIFICATE_VERIFY
      end CONNECTED_PHA_QUERY_SIGNATURE;

      state CONNECTED_PHA_SEND_CERTIFICATE_VERIFY is
         Client_Certificate_Verify_Handshake_Message : TLS_Handshake_Handshake;
      begin
         Client_Certificate_Verify_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_CERTIFICATE_VERIFY, Length => Certificate_Verify'Length, Payload => Certificate_Verify)
            where Certificate_Verify = TLS_Handshake_Certificate_Verify (Keystore_Message.Payload);
         Success := Write (Record_Data_Channel, Client_Certificate_Verify_Handshake_Message);
         Transcript_Hash := Update_Hash (Transcript_Hash, Client_Certificate_Verify_Handshake_Message'Opaque);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then CONNECTED_PHA_SEND_FINISHED
      end CONNECTED_PHA_SEND_CERTIFICATE_VERIFY;

      state CONNECTED_PHA_SEND_FINISHED is
         Verify_Data : GreenTLS_Content;
      begin
         Verify_Data := HMAC (Server_Hello_Message.Cipher_Suite, Finished_Key, Get_Hash (Transcript_Hash));
         Finished_Key := null;
         Finished_Handshake_Message := TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_FINISHED, Length => Finished'Length, Payload => Finished)
            where Finished = TLS_Handshake_Finished'(Verify_Data => Verify_Data);
         Success := Write (Record_Data_Channel, Finished_Handshake_Message);
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
         then CONNECTED
      end CONNECTED_PHA_SEND_FINISHED;

      state CONNECTED_KEY_UPDATE is
         Server_Key : GreenTLS_Content;
         Server_IV : GreenTLS_Content;
         Success_Server : Boolean;
      begin
         Server_Application_Traffic_Secret := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Application_Traffic_Secret.Data), "traffic upd", Get_Hash (Empty_Hash), Hash_Length);
         Server_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Server_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Server_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Success_Server := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_SERVER, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Record_Keys'(Key_Length => Server_Key'Length, Key => Server_Key.Data, IV_Length => Server_IV'Length, IV => Server_IV.Data));
      transition
         then ERROR_INTERNAL_ERROR
            if Success_Server = False
         then CONNECTED_SEND_KEY_UPDATE
            if Key_Update_Message.Request_Update = TLS_Handshake_UPDATE_REQUESTED
         then CONNECTED
      end CONNECTED_KEY_UPDATE;

      state CONNECTED_SEND_KEY_UPDATE is
         Client_Key : GreenTLS_Content;
         Client_IV : GreenTLS_Content;
         Success_Client : Boolean;
      begin
         Success := Write (Record_Data_Channel, TLS_Handshake_Handshake'(Tag => TLS_Handshake_HANDSHAKE_KEY_UPDATE, Length => KU'Length, Payload => KU)
            where KU = TLS_Handshake_Key_Update'(Request_Update => TLS_Handshake_UPDATE_NOT_REQUESTED));
         Client_Application_Traffic_Secret := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Application_Traffic_Secret), "traffic upd", Get_Hash (Empty_Hash), Hash_Length);
         Client_Key := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Application_Traffic_Secret.Data), "key", Get_Hash (Empty_Hash), Keystore_Message.Key_Length);
         Client_IV := HKDF_Expand_Label (GreenTLS_Content'(Data => Client_Application_Traffic_Secret.Data), "iv", Get_Hash (Empty_Hash), Keystore_Message.IV_Length);
         Success_Client := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => GreenTLS_KEY_UPDATE_CLIENT, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Record_Keys'(Key_Length => Client_Key'Length, Key => Client_Key.Data, IV_Length => Client_IV'Length, IV => Client_IV.Data));
      transition
         then ERROR_INTERNAL_ERROR
            if Success = False
               or Success_Client = False
         then CONNECTED
      end CONNECTED_SEND_KEY_UPDATE;

      state ERROR_INVALID_CONFIGURATION is
      begin
         Error := TLS_Alert_ILLEGAL_PARAMETER;
      transition
         then ERROR_SEND_LOCAL
      end ERROR_INVALID_CONFIGURATION;

      state ERROR_UNEXPECTED_MESSAGE is
      begin
         Error := TLS_Alert_UNEXPECTED_MESSAGE;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_UNEXPECTED_MESSAGE;

      state ERROR_BAD_CERTIFICATE is
      begin
         Error := TLS_Alert_BAD_CERTIFICATE;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_BAD_CERTIFICATE;

      state ERROR_UNSUPPORTED_CERTIFICATE is
      begin
         Error := TLS_Alert_UNSUPPORTED_CERTIFICATE;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_UNSUPPORTED_CERTIFICATE;

      state ERROR_CERTIFICATE_REVOKED is
      begin
         Error := TLS_Alert_CERTIFICATE_REVOKED;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_CERTIFICATE_REVOKED;

      state ERROR_CERTIFICATE_EXPIRED is
      begin
         Error := TLS_Alert_CERTIFICATE_EXPIRED;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_CERTIFICATE_EXPIRED;

      state ERROR_CERTIFICATE_UNKNOWN is
      begin
         Error := TLS_Alert_CERTIFICATE_UNKNOWN;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_CERTIFICATE_UNKNOWN;

      state ERROR_ILLEGAL_PARAMETER is
      begin
         Error := TLS_Alert_ILLEGAL_PARAMETER;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_ILLEGAL_PARAMETER;

      state ERROR_DECODE_ERROR is
      begin
         Error := TLS_Alert_DECODE_ERROR;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_DECODE_ERROR;

      state ERROR_DECRYPT_ERROR is
      begin
         Error := TLS_Alert_DECRYPT_ERROR;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_DECRYPT_ERROR;

      state ERROR_PROTOCOL_VERSION is
      begin
         Error := TLS_Alert_PROTOCOL_VERSION;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_PROTOCOL_VERSION;

      state ERROR_INTERNAL_ERROR is
      begin
         Error := TLS_Alert_INTERNAL_ERROR;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_INTERNAL_ERROR;

      state ERROR_MISSING_EXTENSION is
      begin
         Error := TLS_Alert_MISSING_EXTENSION;
      transition
         then ERROR_SEND_REMOTE
      end ERROR_MISSING_EXTENSION;

      state ERROR_SEND_REMOTE is
      begin
         Success := Write (Record_Control_Channel, GreenTLS_Control_Message'(Tag => TLS_Alert_ALERT, Length => Alert_Message'Length, Data => Alert_Message)
            where Alert_Message = GreenTLS_Alert_Message'(Description => Error));
      transition
         then ERROR_SEND_LOCAL
      end ERROR_SEND_REMOTE;

      state ERROR_SEND_LOCAL is
      begin
         Success := Write (Application_Control_Channel, GreenTLS_Application_Control_Message'(Tag => GreenTLS_APPLICATION_ALERT, Length => Data'Length, Data => Data)
            where Data = GreenTLS_Alert_Message'(Description => Error));
      transition
         then TERMINATED
      end ERROR_SEND_LOCAL;

      state TERMINATED is null state;
   end Client;

end TLS_Handshake_Session;
